<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PinFun.Core</name>
    </assembly>
    <members>
        <member name="T:PinFun.Core.Api.ApiDefinition">
            <summary>
            API定义，包含了该API的一些定义信息
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiDefinition.#ctor">
            <summary>
            创建一个新的API定义
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiDefinition.ApiId">
            <summary>
            API编号
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiDefinition.Name">
            <summary>
            当前API的名称，对应方法名
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiDefinition.FullName">
            <summary>
            该API所对应的方法名称, 此名称为全名称，即：程序集文件名+名称空间+接口名称+方法名称，已“.”分隔
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiDefinition.Arguments">
            <summary>
            该API对应的参数清单，如果该API没有参数，那么此数组的长度为0
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiDefinition.ReturnType">
            <summary>
            该API的返回值类型
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiDefinition.ApiPipelines">
            <summary>
            该方法调用过程中需要使用到的管道方法类型，这些类型理论上都继承至<see cref="T:PinFun.Core.Api.IApiPipeline"/>接口
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiDefinition.ApiAttributes">
            <summary>
            定义在当前API方法上的所有属性信息
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.ApiExecuteException">
            <summary>
            API执行过程中产生的异常
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiExecuteException.#ctor(System.String)">
            <summary>
            创建一个API执行过程中产生的异常，该异常通常是业务逻辑中判断失败，code：700
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:PinFun.Core.Api.ApiExecuteException.#ctor(System.Double,System.String)">
            <summary>
            创建一个API执行过程中产生的异常
            </summary>
            <param name="code">异常代码</param>
            <param name="message">异常消息</param>
        </member>
        <member name="M:PinFun.Core.Api.ApiExecuteException.#ctor(System.Double,System.String,System.Exception)">
            <summary>
            创建一个API执行过程中产生的异常
            </summary>
            <param name="code">异常代码</param>
            <param name="message">异常消息</param>
            <param name="innerException">原始异常</param>
        </member>
        <member name="P:PinFun.Core.Api.ApiExecuteException.ExceptionCode">
            <summary>
            异常代码
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.ApiManagerProvider">
            <summary>
            API管理器提供程序，该程序会检查
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiManagerProvider.ApiManager">
            <summary>
            获取当前程序域中的API管理器对象
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.ApiProxyCreator">
            <summary>
            服务器API的本地代理创建器
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.ApiProxyCreator.#ctor(System.String)">
            <summary>
            服务器名称
            </summary>
            <param name="serverName"></param>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.ApiProxyCreator.#ctor(PinFun.Core.Api.ApiProxy.IInvokeTunnel)">
            <summary>
            在指定的通道上发起调用
            </summary>
            <param name="tunnel"></param>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.ApiProxyCreator.GetProxy``1">
            <summary>
            获取指定对象的代理对象
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.ApiProxyFactory">
            <summary>
            服务器API的客户端代理工厂
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.ApiProxyFactory.InitObject(System.Object)">
            <summary>
            初始化指定的对象，该对象内部被<see cref="T:PinFun.Core.Api.Attributes.RemoteApiAttribute"/>标记了的变量将全部被赋值
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.ApiProxyFactory.GetProxy``1">
            <summary>
            获取默认的远程调用服务上的代理对象
            </summary>
            <typeparam name="T">需要代理的类型</typeparam>
            <returns>当前指定类型的代理对象</returns>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.ApiProxyFactory.GetProxy``1(System.String)">
            <summary>
            使用指定的服务器获取代理对象
            </summary>
            <typeparam name="T">需要代理的类型</typeparam>
            <exception cref="T:System.ArgumentNullException">serverName不能为空</exception>
            <param name="serverName">服务器名称</param>
            <returns>当前指定类型的代理对象</returns>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.ApiProxyFactory.GetProxy``1(PinFun.Core.Api.ApiProxy.IInvokeTunnel)">
            <summary>
            在指定的连接通道上获取远程服务的代理对象
            </summary>
            <typeparam name="T">需要代理的类型</typeparam>
            <exception cref="T:System.ArgumentNullException">tunnel不能为空</exception>
            <param name="tunnel">通道</param>
            <returns>当前指定类型的代理对象</returns>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.ClientMetaInfoManager">
            <summary>
            客户端API元数据管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.ClientMetaInfoManager.FindApi(System.Type,System.Reflection.MethodInfo)">
            <summary>
            寻找指定的API信息
            </summary>
            <param name="interfaceType"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.ApiInfo.Api">
            <summary>
            API名称
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.ApiInfo.Method">
            <summary>
            方法名称
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.ApiInfo.MethodInfo">
            <summary>
            方法定义
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.IGenericTaskResultHelper">
            <summary>
            <![CDATA[客户端的Task<T>接口返回值调用帮助接口]]>
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.IGenericTaskResultHelper.Wait(PinFun.Core.Api.ApiProxy.PendingInvokeRequest)">
            <summary>
            等待远程的Task结果
            </summary>
            <param name="pendingInvokeRequest"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.GenericTaskResultHelper`1">
            <summary>
            等待实现
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.GenericTaskResultHelper.Wait(System.Type,PinFun.Core.Api.ApiProxy.PendingInvokeRequest)">
            <summary>
            执行调用，并且返回调用结果
            </summary>
            <param name="returnType"></param>
            <param name="pendingInvokeRequest"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.InvokeResponseReceived">
            <summary>
            收到了服务器返回的调用结果
            </summary>
            <param name="requestId">调用编号</param>
            <param name="responseResult">结果</param>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.BeforeInvoke">
            <summary>
            在调用之前触发
            </summary>
            <param name="request">当前的调用请求</param>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.AfterInvoke">
            <summary>
            在调用得到结果之后触发的事件
            </summary>
            <param name="result">调用结果</param>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.PushDataReceived">
            <summary>
            收到来自服务器推送的数据
            </summary>
            <param name="sender">接收到推送数据的客户端</param>
            <param name="data">原始数据</param>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.IInvokeTunnel">
            <summary>
            可提供API调用的通道, 注意，所有通道需要手动调用<see cref="T:PinFun.Core.Api.ApiProxy.InvokeTunnelManager"/>的RegisteTunnel方法手动注册方能生效
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.IInvokeTunnel.Name">
            <summary>
            通道名称
            </summary>
        </member>
        <member name="E:PinFun.Core.Api.ApiProxy.IInvokeTunnel.OnInvokeResponseReceived">
            <summary>
            收到来自服务器的返回结果
            </summary>
        </member>
        <member name="E:PinFun.Core.Api.ApiProxy.IInvokeTunnel.OnBeforeInvoke">
            <summary>
            在调用之前触发的事件
            </summary>
        </member>
        <member name="E:PinFun.Core.Api.ApiProxy.IInvokeTunnel.OnPushDataReceived">
            <summary>
            收到来自服务器推送的数据事件
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.IInvokeTunnel.SetResultReceiver(System.Action{System.Guid,PinFun.Core.Api.ApiResult,System.Exception})">
            <summary>
            设置用于接受返回结果的方法
            </summary>
            <param name="resultReceiveAction">接受结果，第三个参数可以是触发OnInvokeResponseReceived得到的异常</param>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.IInvokeTunnel.SendInvokeRequest(PinFun.Core.Api.ApiProxy.InvokeRequest)">
            <summary>
            发送调用请求
            </summary>
            <param name="request"></param>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.InvokeRequest">
            <summary>
            调用请求
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.InvokeRequest.#ctor(System.Type,System.Reflection.MethodInfo,System.Object[])">
            <summary>
            新建一个调用请求
            </summary>
            <param name="interfaceType">被调用的类型</param>
            <param name="method">被调用类型中的方法定义</param>
            <param name="arguments">参数清单</param>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.InvokeRequest.RequestId">
            <summary>
            获取调用编号
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.InvokeRequest.Header">
            <summary>
            获取或设置请求头信息
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.InvokeRequest.InterfaceType">
            <summary>
            获取待调用的类型
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.InvokeRequest.Method">
            <summary>
            获取待调用的方法
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.InvokeRequest.Arguments">
            <summary>
            请求参数
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.InvokeRequest.ArgumentNames">
            <summary>
            获取当前方法对应的参数名清单
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.InvokeTunnelManager">
            <summary>
            调用通道管理器，用户可以通过本管理器自行扩展调用通道
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.InvokeTunnelManager.#ctor">
            <summary>
            初始化调用通道管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.InvokeTunnelManager.OnScheduledTask">
            <summary>
            定时扫描超时的调用
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.InvokeTunnelManager.RegisteTunnel(PinFun.Core.Api.ApiProxy.IInvokeTunnel)">
            <summary>
            注册调用通道
            </summary>
            <param name="tunnel">调用通道</param>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.InvokeTunnelManager.FindTunnel(System.String)">
            <summary>
            通过名称寻找某个调用通道
            </summary>
            <param name="name">通道名称</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.InvokeTunnelManager.InvokeOn(System.String,PinFun.Core.Api.ApiProxy.InvokeRequest)">
            <summary>
            在指定的服务器上发起调用
            </summary>
            <param name="server"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.InvokeTunnelManager.GetRequestReturnType(System.Guid)">
            <summary>
            获取指定调用请求所需要的返回值类型
            </summary>
            <param name="requestId">请求编号</param>
            <returns>如果没有找到的话返回null</returns>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.PendingInvokeRequest">
            <summary>
            正在等待结果的调用对象
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.PendingInvokeRequest.RequestId">
            <summary>
            调用编号
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.PendingInvokeRequest.ReturnType">
            <summary>
            调用返回值类型
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiProxy.PendingInvokeRequest.IsTimeOut">
            <summary>
            是否已经超时
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.PendingInvokeRequest.SetResult(PinFun.Core.Api.ApiResult,System.Exception)">
            <summary>
            设置返回值
            </summary>
            <param name="result"></param>
            <param name="exception">调用异常</param>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.PendingInvokeRequest.WaitResult">
            <summary>
            等到结果直到超时或者收到结果
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.PendingInvokeRequest.WaitNormalResult">
            <summary>
            等待普通的，非Task类型的返回值
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ApiProxy.RealApiProxy">
            <summary>
            服务器API的本地真实代理对象，所有的调用均从此对象发起
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiProxy.RealApiProxy.Invoke(System.Reflection.MethodInfo,System.Object[])">
            <summary>
            发起调用
            </summary>
            <param name="targetMethod"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ApiResult">
            <summary>
            通用的API返回值
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiResult.#ctor">
            <summary>
            定义一个通用的返回值对象，该对象具有默认的ReturnCode：200，Message:OK
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiResult.#ctor(System.Int32)">
            <summary>
            尝试从<see cref="P:PinFun.Core.Api.ApiResultCodes.Message"/>自动获取消息
            </summary>
            <param name="code">返回值</param>
        </member>
        <member name="M:PinFun.Core.Api.ApiResult.#ctor(System.Object)">
            <summary>
            创建一个携带返回值的通用返回对象
            </summary>
            <param name="body">返回对象</param>
        </member>
        <member name="M:PinFun.Core.Api.ApiResult.#ctor(System.Double,System.String,System.Object)">
            <summary>
            创建一个携带自定义返回值和消息的通用返回对象
            </summary>
            <param name="code">返回值</param>
            <param name="msg">返回消息</param>
            <param name="body">返回对象</param>
        </member>
        <member name="P:PinFun.Core.Api.ApiResult.ReturnCode">
            <summary>
            返回值, 大部分返回值请参考<see cref="T:PinFun.Core.Api.ApiResultCodes"/>
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiResult.Message">
            <summary>
            返回消息
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiResult.Body">
            <summary>
            具体的返回对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ApiResult.ToString">
            <summary>
            Json字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ApiResultCodes">
            <summary>
            系统预设的API返回值清单
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.Ok">
            <summary>
            成功消息
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.ServerError">
            <summary>
            服务器内部错误:{0}
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.NotFound">
            <summary>
            请求的API未找到
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.InputArgumentsNotMatched">
            <summary>
            输入参数与待执行方法参数个数不匹配
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.ArgumentValidateFailed">
            <summary>
            输入参数校验失败
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.MethodOverloadNotSupported">
            <summary>
            重载的API方法不支持
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.ArgumentAnalysisNotSupported">
            <summary>
            服务器不支持解析当前请求方式的参数
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.ArgumentTypeError">
            <summary>
            传入的参数和目标方法需要的参数类型不匹配
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.ArgumentAnalysisError">
            <summary>
            参数解析错误
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.DataVersionNotMatched">
            <summary>
            更新的数据版本并非最新版本
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.Unauthorized">
            <summary>
            未授权，无权访问当前API
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.AccountNotFound">
            <summary>
            登录账号未找到，无法执行当前操作
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.SessionTimeout">
            <summary>
            会话超时，请重新登录
            </summary>
        </member>
        <member name="F:PinFun.Core.Api.ApiResultCodes.InvalidToken">
            <summary>
            Token验证错误，无法执行当前操作
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ApiResultCodes.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.DefaultMessage">
            <summary>
            默认的消息编码对应的消息
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.DefaultMessage.#ctor">
            <summary>
            默认的消息编码对应的消息
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.DefaultMessage.Item(System.Int32)">
            <summary>
            获取指定编码对应的消息
            </summary>
            <param name="code">编码</param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Api.DefaultMessage.Item(System.Double)">
            <summary>
            获取指定编码对应的消息
            </summary>
            <param name="code">编码</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ArgumentDefinition">
            <summary>
            API参数定义
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ArgumentDefinition.#ctor(System.Reflection.ParameterInfo)">
            <summary>
            新建一个参数定义
            </summary>
            <param name="parameterInfo">原始参数</param>
        </member>
        <member name="P:PinFun.Core.Api.ArgumentDefinition.ArgumentType">
            <summary>
            参数类型
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ArgumentDefinition.ParameterCheckers">
            <summary>
            当前参数的校验方法集合
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ArgumentDefinition.Name">
            <summary>
            参数名称
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.Attributes.ApiAttribute">
            <summary>
            标记一个API接口，改接口可以通过<see cref="T:PinFun.Core.Api.IApiManager"/>的实现类进行访问、调用。
            所有的实现类必须具有一个无参构造函数
            要求所有public的同名方法定义必须具有不同的参数个数
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.Attributes.ApiAttribute.ApiName">
            <summary>
            表示API名称，默认为当前接口名称，如果接口名称首字母为I，那么会被去掉
            <remarks>
            1. 假如接口名称为 IUserAccount, 那么未定义该字段名的时候，访问方式为 */UserAccount/{method name}<br/>
            2. 假如接口名称为 UserAccount,  那么未定义该字段名的时候，访问方式为 */UserAccount/{method name}<br/>
            3. 无论接口名称为什么，当定义了该名称时，访问方式为 */{ApiName}/{method name}<br/>
            </remarks>
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.Attributes.ApiAttribute.SingletonInstance">
            <summary>
            是否是单实例，默认为false
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.Attributes.ApiImplAttribute">
            <summary>
            表示一个API的实现类，默认情况下，可以不用标记
            <para>如果一个接口找到多个实现类并且都没有使用<see cref="T:PinFun.Core.Api.Attributes.ApiImplAttribute"/>进行标记，那么按照其扫描顺序使用最后找到的那个</para>
            <para>如果一个接口找到的多个实现类中包含了标记了<see cref="T:PinFun.Core.Api.Attributes.ApiImplAttribute"/>的实现类，那么默认包含<see cref="T:PinFun.Core.Api.Attributes.ApiImplAttribute"/>标记的实现类优先级更高</para>
            <para>如果一个接口找到的实现类中有多个标记了<see cref="T:PinFun.Core.Api.Attributes.ApiImplAttribute"/>的类，那么默认按照Priority属性的大小进行排序，大的优先</para>
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Attributes.ApiImplAttribute.#ctor">
            <summary>
            标记这个类是某个接口的实现类，采用默认优先级0
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Attributes.ApiImplAttribute.#ctor(System.Int32)">
            <summary>
            标记这个类是某个接口的实现类
            </summary>
            <param name="priority">优先级</param>
        </member>
        <member name="P:PinFun.Core.Api.Attributes.ApiImplAttribute.Priority">
            <summary>
            表示改实现的优先级
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.Attributes.ApiMetaInfoAttribute">
            <summary>
            用于描述API元素信息的标记, 该标记将用于权限控制中
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Attributes.ApiMetaInfoAttribute.#ctor(System.String,System.String[])">
            <summary>
            描述API元素信息
            </summary>
            <param name="apiId">API ID</param>
            <param name="modelIds">该API所属的模块清单</param>
        </member>
        <member name="P:PinFun.Core.Api.Attributes.ApiMetaInfoAttribute.ApiId">
            <summary>
            API ID
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.Attributes.ApiMetaInfoAttribute.ApiName">
            <summary>
            API名称，用于显示
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.Attributes.ApiMetaInfoAttribute.ApiDesc">
            <summary>
            API描述，如果留空，那么默认将读取其xml注释（可行的话）
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.Attributes.ApiMetaInfoAttribute.ModelIds">
            <summary>
            所属模块
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.Attributes.ApiMethodAttribute">
            <summary>
            自定义方法名称，默认情况下采用的就是方法名作为调用名称
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.Attributes.ApiMethodAttribute.Name">
            <summary>
            访问该API的名称，默认为方法名
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.Attributes.BaseApiPipelineAttribute">
            <summary>
            定义在执行业务前或者后需要附带执行的业务逻辑
            <para>注意：</para>
            <para>1: 该属性可以标记在接口上以及接口方法上</para>
            <para>2: 该属性仅能标记在包含了<see cref="T:PinFun.Core.Api.Attributes.ApiAttribute"/>标记的接口方能生效</para>
            <para>3: 如果接口上包含此标记，那么执行当前接口下的所有方法均会调用该标记</para>
            <para>4：如果接口和方法包含同一个标记，那么方法上的标记将被忽略</para>
            <para>5：调用顺序，接口BeforeInvoke->方法BeforeInvoke->方法AfterInvoke->接口AfterInvoke</para>
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Attributes.BaseApiPipelineAttribute.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Attributes.BaseApiPipelineAttribute.BeforeInvoke(PinFun.Core.Api.ApiDefinition,System.Object[])">
            <summary>
            在执行业务方法前执行
            <para>如果该方法抛出<see cref="T:PinFun.Core.Api.ApiExecuteException"/>后续的所有执行逻辑将被中断</para>
            <para>如果该方法抛出了其他异常，将被记录日志然后忽略</para>
            </summary>
            <param name="apiDefinition">当前执行API的定义</param>
            <param name="inputArguments">输入参数清单</param>
        </member>
        <member name="M:PinFun.Core.Api.Attributes.BaseApiPipelineAttribute.AfterInvoke(PinFun.Core.Api.ApiDefinition,System.Exception,System.Object,System.Object[])">
            <summary>
            在执行业务方法之后执行，如果此方法产生了异常，所有类型的异常将被忽略
            </summary>
            <param name="apiDefinition">当前执行API的定义</param>
            <param name="exception">异常，如果有，则表示业务方法执行出错</param>
            <param name="returnValue">业务返回值，如果业务方法是void，那么此值为null</param>
            <param name="inputArguments">输入参数清单</param>
        </member>
        <member name="T:PinFun.Core.Api.Attributes.BaseParameterCheckerAttribute">
            <summary>
            通用的参数校验规则属性基类
            <remarks>所有验证类的错误code均为600.1</remarks>
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Attributes.BaseParameterCheckerAttribute.CheckParameter(System.Object,System.Collections.Generic.Dictionary{System.String,System.Object},System.String@)">
            <summary>
            校验当前参数是否满足验证条件
            </summary>
            <param name="currentParameterValue">待校验参数的值</param>
            <param name="allParameterValues">当前调用输入的所有参数</param>
            <param name="message">出错时返回的消息，可以采用{0}占位符，用于替换成当前参数的参数名称</param>
            <returns>返回校验通过与否, 通过：true，未通过：false</returns>
        </member>
        <member name="T:PinFun.Core.Api.Attributes.RemoteApiAttribute">
            <summary>
            标记当前成员为一个远程服务实现
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Attributes.RemoteApiAttribute.#ctor">
            <summary>
            采用默认的服务器作为调用对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Attributes.RemoteApiAttribute.#ctor(System.String)">
            <summary>
            采用指定的服务器作为调用对象
            </summary>
            <param name="serverName">服务器名称</param>
        </member>
        <member name="P:PinFun.Core.Api.Attributes.RemoteApiAttribute.ServerName">
            <summary>
            获取当前服务所指定的服务器名称
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.FileResult">
            <summary>
            API返回值是文档，API的返回值是此类型，那么不同的服务类型，可能有不同的返回方式
            <para>例如：</para>
            <para>http方式访问：返回的可能是一个直接可下载的文件</para>
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.FileResult.#ctor">
            <summary>
            注意，程序中请不要使用该构造函数，此处增加无参构造函数仅为了在生成文档时候能够自动处理返回值
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.FileResult.#ctor(System.Byte[])">
            <summary>
            创建一个默认的，可下载的文件类型返回值
            </summary>
            <param name="content">文件内容</param>
        </member>
        <member name="M:PinFun.Core.Api.FileResult.#ctor(System.Byte[],System.String)">
            <summary>
            创建一个指定类型的文件类型返回值
            </summary>
            <param name="content">文件内容</param>
            <param name="contentType">文件类型</param>
        </member>
        <member name="M:PinFun.Core.Api.FileResult.#ctor(System.String,System.Byte[])">
            <summary>
            采用默认的文件类型application/octet-stream创建一个文件类型返回值
            </summary>
            <param name="name">文件名</param>
            <param name="content">文件内容</param>
        </member>
        <member name="M:PinFun.Core.Api.FileResult.#ctor(System.String,System.Byte[],System.String)">
            <summary>
            新建一个文件类型返回值
            </summary>
            <param name="name">文件名</param>
            <param name="content">文件内容</param>
            <param name="contentType">文件类型</param>
        </member>
        <member name="P:PinFun.Core.Api.FileResult.FileName">
            <summary>
            文件名
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.FileResult.ContentType">
            <summary>
            文件类型
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.FileResult.Content">
            <summary>
            具体内容
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.IApiManager">
            <summary>
            API管理器接口
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.IApiManager.Init">
            <summary>
            初始化，系统会在开启服务之前，调用此方法，以便于管理器能够先行扫描所有接口实现
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.IApiManager.FindApi(System.String,System.String)">
            <summary>
            依据指定的API名称和方法名称找到API定义
            </summary>
            <param name="api">api名称，对应接口名称</param>
            <param name="name">方法名称</param>
            <returns>返回所有符合条件的API定义</returns>
        </member>
        <member name="M:PinFun.Core.Api.IApiManager.Invoke(System.Guid,System.Object[])">
            <summary>
            调用指定的接口，并且返回调用结果
            </summary>
            <param name="apiId">对应的API ID</param>
            <param name="arguments">对应的参数</param>
            <returns>对应的调用结果</returns>
        </member>
        <member name="T:PinFun.Core.Api.IApiPipeline">
            <summary>
            定义在执行业务前或者后需要附带执行的业务逻辑
            <para>注意：</para>
            <para>1: 该属性可以标记在接口上以及接口方法上</para>
            <para>2: 该属性仅能标记在包含了<see cref="T:PinFun.Core.Api.Attributes.ApiAttribute"/>标记的接口方能生效</para>
            <para>3: 如果接口上包含此标记，那么执行当前接口下的所有方法均会调用该标记</para>
            <para>4：如果接口和方法包含同一个标记，那么方法上的标记将被忽略</para>
            <para>5：调用顺序，接口BeforeInvoke->方法BeforeInvoke->方法AfterInvoke->接口AfterInvoke</para>
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.IApiPipeline.BeforeInvoke(PinFun.Core.Api.ApiDefinition,System.Object[])">
            <summary>
            在执行业务方法前执行
            <para>如果该方法抛出<see cref="T:PinFun.Core.Api.ApiExecuteException"/>后续的所有执行逻辑将被中断</para>
            <para>如果该方法抛出了其他异常，将被记录日志然后忽略</para>
            </summary>
            <param name="apiDefinition">当前执行API的定义</param>
            <param name="inputArguments">输入参数清单</param>
        </member>
        <member name="M:PinFun.Core.Api.IApiPipeline.AfterInvoke(PinFun.Core.Api.ApiDefinition,System.Exception,System.Object,System.Object[])">
            <summary>
            在执行业务方法之后执行，如果此方法产生了异常，所有类型的异常将被忽略
            </summary>
            <param name="apiDefinition">当前执行API的定义</param>
            <param name="exception">异常，如果有，则表示业务方法执行出错</param>
            <param name="returnValue">业务返回值，如果业务方法是void，那么此值为null</param>
            <param name="inputArguments">输入参数清单</param>
        </member>
        <member name="T:PinFun.Core.Api.InvokeContext">
            <summary>
            API调用上下文对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.InvokeContext.SetRequest(PinFun.Core.Api.IInvokeRequest)">
            <summary>
            设置请求对象
            </summary>
            <param name="request"></param>
        </member>
        <member name="P:PinFun.Core.Api.InvokeContext.Request">
            <summary>
            当前调用上下文的请求对象
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.IInvokeRequest">
            <summary>
            API请求接口定义
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.IInvokeRequest.Header">
            <summary>
            当前请求中Header中的内容，如果是http请求，querystring中的字段将采用 ?key（全部转换成小写）的方式放到header中
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.IInvokeRequest.Session">
            <summary>
            基于当前连接的数据存储, 注意，该对象并非线程安全，故在针对连接写当前数据的时候可能需要lock
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.IParameterChecker">
            <summary>
            参数校验接口, 该接口仅能采用Attribute的方式标记在参数上, 注意由于多次调用共享一个对象，故该接口的实现类最好不要保留内部数据
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.IParameterChecker.CheckParameter(System.Object,System.Collections.Generic.Dictionary{System.String,System.Object},System.String@)">
            <summary>
            校验参数
            </summary>
            <param name="currentParameterValue">当前参数值</param>
            <param name="allParameterValues">当前调用的所有参数名称</param>
            <param name="message">错误消息, 占位符{0}表示当前参数的参数名称，占位符{1}表示当前参数的参数类型</param>
            <returns>校验结果</returns>
        </member>
        <member name="T:PinFun.Core.Api.PageResult`1">
            <summary>
            通用的翻页数据返回
            </summary>
            <typeparam name="T">数据类型</typeparam>
        </member>
        <member name="M:PinFun.Core.Api.PageResult`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            通用的翻页数据返回
            </summary>
            <param name="total">总数量</param>
            <param name="data">数据</param>
        </member>
        <member name="P:PinFun.Core.Api.PageResult`1.Total">
            <summary>
            总数量
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.PageResult`1.Data">
            <summary>
            数据
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.PageResult">
            <summary>
            通用的翻页数据返回
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.PageResult.ToPageResult``1(System.Data.IDataReader,System.Int32,System.Int32)">
            <summary>
            通过IDataReader对象返回翻页结果, 外部需要自行释放reader对象
            </summary>
            <typeparam name="T">带返回数据类型</typeparam>
            <param name="reader">reader对象</param>
            <param name="pageIndex">页码</param>
            <param name="pageSize">页大小</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ReflectionApiImpl.ApiInterfaceMetaInfo">
            <summary>
            API元数据，该元数据包含了每个定义为API的接口的定义
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.ApiInterfaceMetaInfo.Name">
            <summary>
            当前API的名称
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.ApiInterfaceMetaInfo.AllMethodMetaInfos">
            <summary>
            当前API所定义的所有方法
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ApiInterfaceMetaInfo.GetInstance">
            <summary>
            获取当前实现类的实例
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo">
            <summary>
            方法元数据
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo.#ctor(System.Reflection.MethodInfo,PinFun.Core.Api.ReflectionApiImpl.ApiInterfaceMetaInfo,System.Type[])">
            <summary>
            新建一个方法元数据对象
            </summary>
            <param name="method">对应的原始方法</param>
            <param name="parent">定义该API的父类元数据信息</param>
            <param name="interfacePipelineTypes">对应的接口上的管道方法类型</param>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo.Method">
            <summary>
            对应的原始方法
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo.ParentMetaInfo">
            <summary>
            父类元数据信息
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo.Name">
            <summary>
            当前API的名称，对应方法名
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo.FullName">
            <summary>
            该API所对应的方法名称, 此名称为全名称，即：程序集文件名+名称空间+接口名称+方法名称，已“.”分隔
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo.Arguments">
            <summary>
            该API对应的参数清单，如果该API没有参数，那么此数组的长度为0
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo.ReturnType">
            <summary>
            该API的返回值类型
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo.ApiPipelines">
            <summary>
            该方法调用过程中需要使用到的管道方法类型，这些类型理论上都继承至<see cref="T:PinFun.Core.Api.IApiPipeline"/>接口
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo.ApiAttributes">
            <summary>
            定义在当前API方法上的所有属性信息
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.ReflectionApiImpl.ApiPipelineManager">
            <summary>
            管道管理器
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.ReflectionApiImpl.IGenericTaskCall">
            <summary>
            <![CDATA[服务器接口返回值为Task<T>类型的API调用助手接口]]>
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.ReflectionApiImpl.GenericTaskCallHelper`1">
            <summary>
            <![CDATA[真实的Task<T>类型返回值API调用实现类]]>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:PinFun.Core.Api.ReflectionApiImpl.GenericTaskCallHelper">
            <summary>
            <![CDATA[服务器端的Task<T>类型API调用助手]]>
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.GenericTaskCallHelper.RunTask(System.Type,System.Object)">
            <summary>
            执行调用，并且返回调用结果
            </summary>
            <param name="returnType"></param>
            <param name="taskObject"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ReflectionApiImpl.ModelValidationMetaDataManager">
            <summary>
            所有基于System.ComponentModel.DataAnnotations空间下的验证属性元数据管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ModelValidationMetaDataManager.GetAllValidationAttributes(System.Type)">
            <summary>
            获取指定类型上的需要验证的属性集合
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Api.ReflectionApiImpl.PropertyValidationMetaData">
            <summary>
            每个属性上面的验证逻辑元数据
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.PropertyValidationMetaData.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            依据属性信息包裹一个元数据对象
            </summary>
            <param name="fieldInfo"></param>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.PropertyValidationMetaData.GetValue(System.Object)">
            <summary>
            从指定的对象上获取该属性的值
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.PropertyValidationMetaData.GetValidations">
            <summary>
            获取该属性上定义的所有验证逻辑
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.PropertyValidationMetaData.GetVerificationRules">
            <summary>
            获取自定义验证属性
            </summary>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.PropertyValidationMetaData.HasValidation">
            <summary>
            是否需要验证,或具有验证规则
            </summary>
        </member>
        <member name="P:PinFun.Core.Api.ReflectionApiImpl.PropertyValidationMetaData.Name">
            <summary>
            当前属性的名称
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.ReflectionApiImpl.ReflectionApiManagerImpl">
            <summary>
            基于反射的API管理器, 该类不能直接实例化，需要使用ReflectionApiManagerImpl.Instance进行访问
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ReflectionApiManagerImpl.FindApi(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ReflectionApiManagerImpl.Invoke(System.Guid,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ReflectionApiManagerImpl.Invoke(System.Guid,System.Text.StringBuilder,PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo,System.Object[])">
            <summary>
            验证参数，并且在合法的情况下调用API
            </summary>
            <param name="reqId"></param>
            <param name="log"></param>
            <param name="api"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ReflectionApiManagerImpl.Invoke(System.Guid,PinFun.Core.Api.ReflectionApiImpl.ApiInterfaceMetaInfo,PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo,System.Object[])">
            <summary>
            真正的方法调用
            </summary>
            <param name="reqId"></param>
            <param name="apiInterfaceMetaInfo"></param>
            <param name="api"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ReflectionApiManagerImpl.BeforeInvoke(System.Guid,PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo,System.Object[])">
            <summary>
            执行管道前置方法
            </summary>
            <param name="reqId"></param>
            <param name="api"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ReflectionApiManagerImpl.AfterInvoke(System.Guid,PinFun.Core.Api.IApiPipeline[],PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo,System.Exception,System.Object,System.Object[])">
            <summary>
            执行管道后置方法
            </summary>
            <param name="reqId"></param>
            <param name="pipelines"></param>
            <param name="api"></param>
            <param name="exception"></param>
            <param name="returnObject"></param>
            <param name="arguments"></param>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ReflectionApiManagerImpl.ValidateParameters(PinFun.Core.Api.ReflectionApiImpl.ApiMethodMetaInfo,System.Object[])">
            <summary>
            参数有效性验证
            </summary>
            <param name="api"></param>
            <param name="values"></param>
        </member>
        <member name="M:PinFun.Core.Api.ReflectionApiImpl.ReflectionApiManagerImpl.ValidateComplexObject(System.Object,System.Text.StringBuilder,System.Boolean@)">
            <summary>
            尝试验证复合类型，一般情况下该类型是一个类的对象，主要验证其内部使用System.ComponentModel.DataAnnotations下的
            </summary>
            <param name="target"></param>
            <param name="message"></param>
            <param name="passed"></param>
        </member>
        <member name="T:PinFun.Core.Api.TaskExecuteException">
            <summary>
            执行Task相关API出错
            </summary>
        </member>
        <member name="T:PinFun.Core.Api.Validators.MinValueAttribute">
            <summary>
            最小值验证
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Validators.MinValueAttribute.#ctor(System.Double)">
            <summary>
            最小值验证
            </summary>
            <param name="min">参数的值必须大于该值</param>
        </member>
        <member name="M:PinFun.Core.Api.Validators.MinValueAttribute.CheckParameter(System.Object,System.Collections.Generic.Dictionary{System.String,System.Object},System.String@)">
            <summary>
            
            </summary>
            <param name="currentParameterValue"></param>
            <param name="allParameterValues"></param>
            <param name="message"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:PinFun.Core.Api.Validators.NotEqualToAttribute">
            <summary>
            必须和某个其他参数的值不同的验证规则
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Validators.NotEqualToAttribute.#ctor(System.String)">
            <summary>
            必须和某个其他参数的值不同的验证规则
            </summary>
            <param name="equalTo">相比较的参数名称</param>
        </member>
        <member name="M:PinFun.Core.Api.Validators.NotEqualToAttribute.CheckParameter(System.Object,System.Collections.Generic.Dictionary{System.String,System.Object},System.String@)">
            <inheritdoc />
        </member>
        <member name="T:PinFun.Core.Api.Validators.RequiredAttribute">
            <summary>
            必填验证，目前支持GUID、String
            </summary>
        </member>
        <member name="M:PinFun.Core.Api.Validators.RequiredAttribute.CheckParameter(System.Object,System.Collections.Generic.Dictionary{System.String,System.Object},System.String@)">
            <summary>
            必填验证
            </summary>
            <param name="currentParameterValue"></param>
            <param name="allParameterValues"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Client.JsonTcpApi.EventLoopBootstrapManager">
            <summary>
            EventLoop和Bootstrap的管理器，主要用于管理客户端连接远程时候同一个类型的客户端异步事件对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.EventLoopBootstrapManager.GetEventLoopBootstrap(System.Object,System.Action{DotNetty.Transport.Channels.MultithreadEventLoopGroup,DotNetty.Transport.Bootstrapping.Bootstrap})">
            <summary>
            获取异步事件对象
            </summary>
            <param name="target"></param>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient">
            <summary>
            基于TCP API服务的客户端
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.#ctor(System.String,System.Int32)">
            <summary>
            新建一个客户端
            </summary>
            <param name="serverInfo"></param>
            <param name="port"></param>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.BuildChannel(DotNetty.Transport.Channels.IChannelPipeline)">
            <summary>
            
            </summary>
            <param name="channelPipeline"></param>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.EnableNettyLog">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.AutoHeartbeat">
            <summary>
            启用自动心跳
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.GetLogger">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.OnDataReceived(System.Object)">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.OnException(System.Exception)">
            <summary>
            
            </summary>
            <param name="exception"></param>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.AutoReConnect">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.HeartbeatData">
            <summary>
            心跳包数据
            </summary>
            <returns></returns>
        </member>
        <member name="E:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.OnPushDataReceived">
            <summary>
            收到来自服务器推送的数据事件
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.EnableNettyLog(System.Boolean)">
            <summary>
            开启或者禁用Netty日志
            </summary>
            <param name="enabled"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.WithName(System.String)">
            <summary>
            设置当前连接的名称
            </summary>
            <param name="name">连接名称</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.SendInvokeRequest(PinFun.Core.Api.ApiProxy.InvokeRequest)">
            <summary>
            发送调用请求
            </summary>
            <param name="request"></param>
        </member>
        <member name="E:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.OnInvokeResponseReceived">
            <summary>
            收到返回事件
            </summary>
        </member>
        <member name="E:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.OnBeforeInvoke">
            <summary>
            发起调用前
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClient.SetResultReceiver(System.Action{System.Guid,PinFun.Core.Api.ApiResult,System.Exception})">
            <summary>
            设置结果接收器
            </summary>
            <param name="resultReceiveAction"></param>
        </member>
        <member name="T:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClientManager">
            <summary>
            由配置节点JsonTcpApiServer初始化出来的JsonTcpApiClient管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClientManager.#ctor">
            <summary>
            初始化管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClientManager.Init">
            <summary>
            该方法内部为空，仅做初始化触发使用
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClientManager.FindClient(System.String)">
            <summary>
            找到指定名称的客户端
            </summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClientManager.InvInit">
            <summary>
            反初始化
            </summary>
        </member>
        <member name="T:PinFun.Core.Client.JsonTcpApi.JsonTcpApiConfig">
            <summary>
            JsonTcpApi服务器配置
            </summary>
        </member>
        <member name="P:PinFun.Core.Client.JsonTcpApi.JsonTcpApiConfig.Name">
            <summary>
            服务器名称
            </summary>
        </member>
        <member name="P:PinFun.Core.Client.JsonTcpApi.JsonTcpApiConfig.Server">
            <summary>
            服务器IP地址
            </summary>
        </member>
        <member name="P:PinFun.Core.Client.JsonTcpApi.JsonTcpApiConfig.Port">
            <summary>
            服务器端口
            </summary>
        </member>
        <member name="P:PinFun.Core.Client.JsonTcpApi.JsonTcpApiConfig.CertificateFile">
            <summary>
            加密证书信息, XX.cer
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.JsonTcpApi.JsonTcpApiConfig.GetConfigTemplate">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Client.RestClient.ContentTypes">
            <summary>
            提交内容类型
            </summary>
        </member>
        <member name="F:PinFun.Core.Client.RestClient.ContentTypes.ApplicationJson">
            <summary>
            json格式
            </summary>
        </member>
        <member name="F:PinFun.Core.Client.RestClient.ContentTypes.ApplicationXWwwFormUrlencoded">
            <summary>
            普通Form表单
            </summary>
        </member>
        <member name="T:PinFun.Core.Client.RestClient.HttpClient">
            <summary>
            用于发起Http请求的对象封装
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.#ctor">
            <summary>
            初始化一个客户端对象, 默认采用Post请求
            </summary>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.WithLog(log4net.ILog)">
            <summary>
            设置Log对象
            </summary>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.WithUrl(System.String)">
            <summary>
            设置当前请求需要访问的地址, 注意，该操作会重置所有设置信息，因此任何请求应该首先调用此方法确定需要发起请求的地址
            </summary>
            <param name="url">地址</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.WithMethod(System.Net.Http.HttpMethod)">
            <summary>
            设置请求方法
            </summary>
            <param name="method">请求方法</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.SetHeader(System.String,System.String)">
            <summary>
            设置请求头信息
            </summary>
            <param name="name">字段名</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.SetContentType(System.String)">
            <summary>
            设置请求的内容类型
            </summary>
            <param name="contentType">类型, 预设值参考<see cref="T:PinFun.Core.Client.RestClient.ContentTypes"/></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.SetForm(System.String,System.String)">
            <summary>
            设置当前请求的Form表单值
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.SetBody(System.Object)">
            <summary>
            设置请求Body
            </summary>
            <param name="body">body对象</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.Send">
            <summary>
            发起请求，并且获取返回数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.Send``1(System.Text.Encoding)">
            <summary>
            发起请求，并且将返回内容按照Json方式解析为指定的对象
            </summary>
            <typeparam name="T"></typeparam>
            <param name="responseEncoding">采用指定的编码方式解析内容，默认为UTF-8</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Client.RestClient.HttpClient.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="T:PinFun.Core.Config.ConfigurationMetadataAttribute">
            <summary>
            主配置节点元数据信息
            </summary>
        </member>
        <member name="M:PinFun.Core.Config.ConfigurationMetadataAttribute.#ctor(System.String)">
            <summary>
            主配置节点元数据信息
            </summary>
            <param name="name">配置节点名称</param>
        </member>
        <member name="P:PinFun.Core.Config.ConfigurationMetadataAttribute.Name">
            <summary>
            配置节点名称
            </summary>
        </member>
        <member name="P:PinFun.Core.Config.ConfigurationMetadataAttribute.Description">
            <summary>
            当前配置的说明信息
            </summary>
        </member>
        <member name="P:PinFun.Core.Config.ConfigurationMetadataAttribute.IsArray">
            <summary>
            是否是数组类型
            </summary>
        </member>
        <member name="T:PinFun.Core.Config.IConfiguration">
            <summary>
            可在配置文件中配置的主节点定义对象，可以通过<see cref="T:PinFun.Core.Config.ConfigurationMetadataAttribute"/>标记配置节点信息，如果没有标记的话那么默认用类名称代替
            </summary>
        </member>
        <member name="M:PinFun.Core.Config.IConfiguration.GetConfigTemplate">
            <summary>
            获取可用于配置的模板对象
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.Attributes.DefaultValueAttribute">
            <summary>
            默认值
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Attributes.DefaultValueAttribute.#ctor(System.String)">
            <summary>
            默认值
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:PinFun.Core.DataBase.Attributes.DefaultValueAttribute.Value">
            <summary>
            默认值
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Attributes.IgnoreMigrationAttribute">
            <summary>
            表示该字段或者表不应该出现在数据库中
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Attributes.LengthAttribute">
            <summary>
            表示当前字段的长度
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Attributes.LengthAttribute.Length">
            <summary>
            字段总长度 
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Attributes.LengthAttribute.DecimalDigits">
            <summary>
            小数位数，仅对decimal数字类型有效
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Attributes.LengthAttribute.#ctor(System.Int32)">
            <summary>
            规定长度
            </summary>
            <param name="length">总长度 </param>
        </member>
        <member name="M:PinFun.Core.DataBase.Attributes.LengthAttribute.#ctor(System.Int32,System.Int32)">
            <summary>
            规定长度
            </summary>
            <param name="length">总长度 </param>
            <param name="decimalDigits">小数位数</param>
        </member>
        <member name="T:PinFun.Core.DataBase.Attributes.NotNullAttribute">
            <summary>
            表示该字段必填
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Attributes.PrimaryKeyAttribute">
            <summary>
            表示当前字段为数据库中的主键
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Attributes.UseDbTypeAttribute">
            <summary>
            强制在数据库中使用指定的类型
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Attributes.UseDbTypeAttribute.#ctor(System.String)">
            <summary>
            定义当前列在数据库中使用的类型
            </summary>
            <param name="dbType">数据库类型，注意，此次用户需要自行处理该类型在不同数据库中的兼容性</param>
        </member>
        <member name="P:PinFun.Core.DataBase.Attributes.UseDbTypeAttribute.DbType">
            <summary>
            获取当前列即将使用的数据库类型
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Db">
            <summary>
            DB访问对象
            <para>注意：建议将此对象放在方法内部，不要在类内部共享，原因在于该对象内部仅有一个数据库连接和事务，共享在多线程情况下可能有问题</para>
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.#ctor(PinFun.Core.DataBase.DbTypes,System.String,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            新建一个DB对象
            <para>连接字符串参考：</para>
            <para>SqlServer: server=192.168.0.30;database=FAISV3_DEV;uid=sa;pwd=Aa123456</para>
            <para>MySql: server=192.168.0.30;database=fx_dev;uid=root;pwd=</para>
            <para>Sqlite: Data Source=TestSqliteDb.db;Pooling=true;FailIfMissing=false</para>
            <para>注意：SqlServer采用了的事务隔离级别非默认，采用的是Snapshot模式，需要在数据库中开启相关功能</para>
            </summary>
            <param name="dbType">数据库类型</param>
            <param name="connectionString">连接字符串</param>
            <param name="enableLog">启用日志</param>
            <param name="commandTimeout">命令执行超时时长</param>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.BeingTransaction(System.Data.IsolationLevel)">
            <summary>
            使用指定的隔离级别开启事务
            </summary>
            <exception cref="T:System.InvalidOperationException">内部已经开启过事务，无法重复开启，请检查代码</exception>
            <param name="isolationLevel">事务隔离级别</param>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.CancelTransaction">
            <summary>
            取消事务，此操作会直接回滚事务，如果内部尚未开启事务，那么直接返回true，否则返回回滚结果
            </summary>
            <exception cref="T:System.InvalidOperationException">FinishTransaction或者CancelTransaction方法仅能调用一次</exception>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.BeingTransaction">
            <summary>
            使用默认的事务隔离级别开启事务
            <exception cref="T:System.InvalidOperationException">内部已经开启过事务，无法重复开启，请检查代码</exception>
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.FinishTransaction">
            <summary>
            完成事务，尝试提交，如果提交失败,返回false并且系统会自动回滚，否则为true
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.Dispose">
            <summary>
            关闭连接，释放资源
            <para>注意：调用释放方法之后不能在执行其他操作</para>
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Db.IsDisposed">
            <summary>
            对象是否已经释放
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Db.CurrentConnection">
            <summary>
            获取当前DB对象所持有的数据库连接对象
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Db.DatabaseType">
            <summary>
            当前数据库的数据库类型
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.IsInTransaction">
            <summary>
            判断当前是否是在事务环境下
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.CacheEvent(PinFun.Core.EventSubscription.ISubscriptionEvent)">
            <summary>
            临时缓存待触发的事件
            </summary>
            <param name="subscriptionEvent"></param>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.Execute(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行SQL语句或者存储过程等
            </summary>
            <param name="sql">SQL语句或者存储过程等</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>影响行数</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.ExecuteAsync(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行SQL语句或者存储过程等
            </summary>
            <param name="sql">SQL语句或者存储过程等</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>影响行数</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.ExecuteReader(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询脚本，并且返回IDataReader对象
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.ExecuteReaderAsync(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行查询脚本，并且返回IDataReader对象
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.ExecuteScalar(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行脚本，返回首行首列
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>首行首列</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.ExecuteScalar``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行脚本，返回首行首列的值到指定类型
            </summary>
            <typeparam name="T">返回对象类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.ExecuteScalarAsync``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行脚本，返回首行首列的值到指定类型
            </summary>
            <typeparam name="T">返回对象类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.Query``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询脚本，返回对象列表
            </summary>
            <typeparam name="T">返回对象类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>对象列表</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.Query(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询脚本，返回dynamic对象列表
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>dynamic对象列表</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryAsDataTable(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询脚本，返回DataSet对象列表
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>结果集</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryAsync(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行查询，返回dynamic对象列表
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>dynamic对象列表</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryAsync``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行查询，并且返回指定对象类型的列表
            </summary>
            <typeparam name="T">返回对象类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>对象列表</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryFirst``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询，并且返回指定类型的第一个对象
            </summary>
            <typeparam name="T">返回对象类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>第一个对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryFirst(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询，并且返回第一个dynamic对象
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>dynamic对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryFirstAsync(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行查询，返回第一个dynamic对象
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>dynamic对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryFirstAsync``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行查询，返回第一个指定类型的对象
            </summary>
            <typeparam name="T">对象类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>指定类型的对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryFirstOrDefault``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询，返回查询结果的第一个对象或者默认对象
            </summary>
            <typeparam name="T">对象类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>指定类型的对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryFirstOrDefault(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询，返回查询结果的第一个或者默认dynamic
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>dynamic对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryFirstOrDefaultAsync(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行查询，返回查询结果的第一个或者默认dynamic
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>dynamic对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryFirstOrDefaultAsync``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
             异步执行查询，返回查询结果的第一个或者默认T
            </summary>
            <typeparam name="T">返回数据类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>T对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryMultiple(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询，并且返回多个结果集
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>结果集</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QueryMultipleAsync(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行查询，并且返回多个结果集
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>结果集</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QuerySingle``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询，并且返回唯一的一个结果
            </summary>
            <typeparam name="T">返回类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>T对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QuerySingle(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行查询，并且返回唯一的一个dynamic结果
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>dynamic对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QuerySingleAsync(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行脚本，并且返回唯一的一个dynamic结果
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>dynamic对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QuerySingleAsync``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行脚本，并且返回唯一的一个T
            </summary>
            <typeparam name="T">返回类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>T对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QuerySingleOrDefault(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行脚本，返回唯一的一个对象或者是默认值
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>dynamic对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QuerySingleOrDefault``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            执行脚本，返回唯一的一个T对象或者是T的默认值
            </summary>
            <typeparam name="T">返回类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>T对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QuerySingleOrDefaultAsync(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行脚本，并且返回唯一的一个或者默认的一个dynamic对象
            </summary>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>dynamic对象</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Db.QuerySingleOrDefaultAsync``1(System.String,System.Object,System.Nullable{System.Data.CommandType})">
            <summary>
            异步执行脚本，并且返回唯一的一个或者默认的一个T对象
            </summary>
            <typeparam name="T">返回对象类型</typeparam>
            <param name="sql">脚本</param>
            <param name="param">参数</param>
            <param name="commandType">脚本类型</param>
            <returns>T对象</returns>
        </member>
        <member name="T:PinFun.Core.DataBase.DbConfig">
            <summary>
            数据库配置
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.DbConfig.DbType">
            <summary>
            数据库类型
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.DbConfig.IsEncrypt">
            <summary>
            是否加密
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.DbConfig.ConnectionString">
            <summary>
            定义的数据库连接字符串
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.DbConfig.SqlLog">
            <summary>
            是否记录所有的查询语句
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.DbConfig.CommandTimeout">
            <summary>
            命令执行超时配置, null则使用默认值
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.DbConfig.GetConfigTemplate">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.DbManager">
            <summary>
            数据库管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.DbManager.Decrypt(System.String)">
            <summary>
            解密连接字符串
            </summary>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.DbManager.Encrypt(System.String)">
            <summary>
            加密连接字符串 
            </summary>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.DataBase.DbManager.DefaultDbConfig">
            <summary>
            获取当前系统中默认的数据库配置, 对此对象的更改不会影响内部的<see cref="M:PinFun.Core.DataBase.DbManager.Create"/>方法，但仍然不建议直接修改该对象
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.DbManager.Create">
            <summary>
            新建一个对象返回，并且将当前对象放到上下文中
            <para>注意：</para>
            <para>1: 主线程获取的DB对象，子线程在获取的时候得到的是和主线程一样的对象</para>
            <para>2: 如果主线程没有主动获取db对象，子线程获取了对象，那么返回主线程之后，主线程在获取的对象是一个新的对象，而非子线程创建的对象</para>
            <para>3: 建议将此对象放在方法内部，不要在类内部共享，原因在于该对象内部仅有一个数据库连接和事务，共享在多线程情况下可能有问题</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.DbManager.Create(PinFun.Core.DataBase.DbConfig)">
            <summary>
            新建一个对象返回，并且将当前对象放到上下文中
            <para>注意：</para>
            <para>1: 主线程获取的DB对象，子线程在获取的时候得到的是和主线程一样的对象</para>
            <para>2: 如果主线程没有主动获取db对象，子线程获取了对象，那么返回主线程之后，主线程在获取的对象是一个新的对象，而非子线程创建的对象</para>
            <para>3: 建议将此对象放在方法内部，不要在类内部共享，原因在于该对象内部仅有一个数据库连接和事务，共享在多线程情况下可能有问题</para>
            </summary>
            <param name="config">配置信息</param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.DataBase.DbManager.ContextDb">
            <summary>
            获取当前调用上下文中创建的DB对象，可能为NULL
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.DbTypes">
            <summary>
            数据库类型
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.DbTypes.MySql">
            <summary>
            MySql
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.DbTypes.MsSql">
            <summary>
            SqlServer
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.DbTypes.Sqlite">
            <summary>
            Sqlite
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Entity.BaseEntity">
            <summary>
            所有业务实体类的基类，当然，如果不需要公共属性，也可以不用继承至该类
            <para>注意：所有该类的子类均可以作为订阅事件的事件源</para>
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.BaseEntity.#ctor">
            <summary>
            设置默认参数
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.BaseEntity.CreateByName">
            <summary>
            创建人姓名
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.BaseEntity.CreateAt">
            <summary>
            创建时间
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.BaseEntity.CreateId">
            <summary>
            创建人编号
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.BaseEntity.LastUpdateByName">
            <summary>
            最后更新人姓名
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.BaseEntity.LastUpdateAt">
            <summary>
            最后更新时间
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.BaseEntity.LastUpdateId">
            <summary>
            最后更新人编号
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Entity.BaseEntityVersioned">
            <summary>
            带版本管理功能的实体对象
            <para>工作原理：
            系统自动对表进行按年方式的分类，例如某条数据的创建时间是2019年，那么其查询的表名称应该是 XX表_2019
            该类对象具有唯一的默认主键字段 Uuid, 表中，采用Uuid+Version作为唯一主键
            IsLastVersion=true的始终是最后一个版本，也就是说IsLastVersion=true的Version始终最大
            </para>
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.BaseEntityVersioned.Update">
            <summary>
            将当前对象更新到数据中, 更新步骤为：
            <para>1: 依据当前数据的uuid和ver版本号，将数据的IsLastVersion字段设置成false</para>
            <para>2: 如果上一步返回的结果为1，那么继续，否则抛出<see cref="T:PinFun.Core.Api.ApiExecuteException"/>错误 其中 Code=700</para>
            <para>3: 将当前数据的版本号+1，然后插入到数据库中，让其变成最新的版本</para>
            <para>4: 返回第三步插入数据时候影响的行数</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.BaseEntityVersioned.Insert">
            <summary>
            将当前对象插入到数据库中，采用的版本号默认为0, 优先使用上下文的数据库对象，如果没有则创建一个, 该方法返回的数量理论上应该是1
            </summary>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.BaseEntityVersioned.Ver">
            <summary>
            当前数据版本号
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.BaseEntityVersioned.Uuid">
            <summary>
            主键, 外部程序需要自行赋值，注意，该字段的值只能使用<see cref="T:PinFun.Core.Utils.SnowflakeId"/>类下的NextId方法获取，该方法返回的数据具有特殊格式，前4位表示年份，系统会依据此字段确认当前数据应该去哪个表中获取或者插入到哪个表中
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.BaseEntityVersioned.IsLastVersion">
            <summary>
            是否是最后一个版本
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Entity.IVersionedEntity">
            <summary>
            此接口仅用于扫描表待版本管理的表使用
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Entity.VersionedEntityInfo`1">
            <summary>
            带版本管理实体的数据信息管理类, 用户可以通过该类获取数据版本的相关信息
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.VersionedEntityInfo`1.#ctor(`0)">
            <summary>
            新建一个带版本管理实体的数据信息
            </summary>
            <param name="lastData">最后一个版本信息</param>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.VersionedEntityInfo`1.AddChange(System.DateTime,System.Guid,System.String)">
            <summary>
            向变更列表中添加变更里程，并且返回对应对象
            </summary>
            <param name="changeAt">变更时间</param>
            <param name="changerId">变更人编号</param>
            <param name="changerName">变更人姓名</param>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.VersionedEntityInfo`1.LastData">
            <summary>
            当前数据的最后一个版本
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.VersionedEntityInfo`1.ChangeMilestones">
            <summary>
            变更信息
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Entity.DataChangeMilestone">
            <summary>
            带版本号的数据变更里程碑
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.DataChangeMilestone.#ctor(System.DateTime,System.Guid,System.String)">
            <summary>
            新建一个带版本号的数据变更里程碑
            </summary>
            <param name="changeAt">变更时间</param>
            <param name="changerId">变更人编号</param>
            <param name="changerName">变更人姓名</param>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.DataChangeMilestone.ChangerId">
            <summary>
            变更人编号
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.DataChangeMilestone.ChangerName">
            <summary>
            变更人姓名
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.DataChangeMilestone.AddChangeItem(PinFun.Core.DataBase.Entity.ChangeItem)">
            <summary>
            向当前里程中添加变更信息
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.DataChangeMilestone.ChangeAt">
            <summary>
            发生变化的时间
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.DataChangeMilestone.Audits">
            <summary>
            发生变化的具体内容
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Entity.ChangeItem">
            <summary>
            发生变化的条目具体信息
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.ChangeItem.#ctor(System.String,System.Object,System.Object)">
            <summary>
            新建一个变更信息
            </summary>
            <param name="propName">发生变更的属性名称</param>
            <param name="old">原值</param>
            <param name="new">新值</param>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.ChangeItem.PropName">
            <summary>
            发生变化的属性名称
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.ChangeItem.OldValue">
            <summary>
            原始值
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.ChangeItem.NewValue">
            <summary>
            新值
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Entity.VT">
            <summary>
            针对携带版本的表操作方法简化调用类
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.VT.Query``1(System.DateTime,System.DateTime,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            查询某个带版本号的表的数据, 内部会自动增加排序规则：按CreateAt降序排列
            </summary>
            <typeparam name="T">待返回数据的数据类型</typeparam>
            <param name="begin">数据创建 开始时间</param>
            <param name="end">数据创建 结束时间</param>
            <param name="where">扩展的Where子句</param>
            <param name="arguments">扩展Where子句中携带的参数</param>
            <returns>返回指定时间范围内的数据</returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.VT.Query``1(System.DateTime,System.DateTime,System.Int32,System.Int32,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            执行分页查询, 例如，取第一页（每页20条记录）那么 参数 skip=20(页大小)*0(页码) take=20, 内部会自动增加排序规则：按CreateAt降序排列
            </summary>
            <typeparam name="T">待返回的数据类型</typeparam>
            <param name="begin">开始时间</param>
            <param name="end">结束时间</param>
            <param name="skip">需要跳过的行数</param>
            <param name="take">需要返回的行数</param>
            <param name="where">附加查询条件</param>
            <param name="arguments">附加查询条件参数</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.VT.QueryFirstOrDefault``1(System.String)">
            <summary>
            通过主键查询某个版本表的某条记录
            </summary>
            <typeparam name="T">待返回数据类型</typeparam>
            <param name="uuid">主键，即UUID</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Entity.VT.GetChangeAudit``1(System.String)">
            <summary>
            获取某项数据的变更历史
            </summary>
            <typeparam name="T">指定的数据类型</typeparam>
            <param name="uuid">数据主键</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.Entity.PageQueryResult`1">
            <summary>
            分页查询结果
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.PageQueryResult`1.Result">
            <summary>
            数据结果
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Entity.PageQueryResult`1.Total">
            <summary>
            总数量
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.ITable">
            <summary>
            表示当前类映射到数据库中的一张表
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.BaseEntityScriptManager">
            <summary>
            实体类的sql管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.BaseEntityScriptManager.GetScripts``1">
            <summary>
            获取指定类型的SQL集合对象, 注意<see cref="T:PinFun.Core.DataBase.Schema.ISqlScripts"/>对象的表名称可能需要在外部进行替换，{0} 表示表名称
            </summary>
            <typeparam name="T">待获取对象类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.BaseEntityScriptManager.GetScripts(System.Type)">
            <summary>
            获取指定类型的SQL集合对象, 注意<see cref="T:PinFun.Core.DataBase.Schema.ISqlScripts"/>对象的表名称可能需要在外部进行替换，{0} 表示表名称
            </summary>
            <param name="type">待获取对象类型</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.Column">
            <summary>
            列定义
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.Column.#ctor">
            <summary>
            新建一个列定义
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.Column.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            新建一个列定义
            </summary>
            <param name="property">列映射的属性</param>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Column.Property">
            <summary>
            当前列所对应的原始属性
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Column.Name">
            <summary>
            字段名称
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Column.IsPrimaryKey">
            <summary>
            是否是主键
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Column.IsNotNull">
            <summary>
            是否必填
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Column.TotalLength">
            <summary>
            总长度
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Column.DecimalDigits">
            <summary>
            小数长度
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Column.ClrType">
            <summary>
            在Clr中的数据类型
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Column.IsEnum">
            <summary>
            获取当前类型是否是枚举类型
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Column.Default">
            <summary>
            默认值
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Column.CustomerDbType">
            <summary>
            用户自定义的数据库类型 
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.Column.IsChanged(PinFun.Core.DataBase.Schema.Column)">
            <summary>
            确定参数的column是否和当前对象相等，Name和IsPrimaryKey忽略
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.DataBase">
            <summary>
            数据库定义
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.DataBase.#ctor">
            <summary>
            新建一个数据库定义
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.DataBase.AddTable(System.Type)">
            <summary>
            向数据库中添加表
            </summary>
            <param name="type">待添加表的类型</param>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.DataBase.Tables">
            <summary>
            获取当前数据库的所有表定义
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.IDatabaseMaintainer">
            <summary>
            数据库维护提供程序接口
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.IDatabaseMaintainer.DbName">
            <summary>
            数据库名称
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.IDatabaseMaintainer.ModifyDataBase(PinFun.Core.DataBase.Schema.DataBase)">
            <summary>
            依据当前扫描情况，更新数据库
            </summary>
            <param name="db"></param>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.IDatabaseMaintainer.DbType">
            <summary>
            当前程序所支持的数据库类型
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.IDatabaseMaintainer.GenerateCreateTableScript(PinFun.Core.DataBase.Schema.Table,System.String)">
            <summary>
            生成某个表的创建脚本
            </summary>
            <param name="table">表定义</param>
            <param name="tableName">自定义表名称，如果为NULL那么采用默认值</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.IDatabaseMaintainer.CreateIndexForTable(System.Data.IDbConnection,PinFun.Core.DataBase.Schema.Table)">
            <summary>
            为指定的表创建索引
            </summary>
            <param name="connection">连接对象</param>
            <param name="table">表定义</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.IDatabaseMaintainer.HasTable(PinFun.Core.DataBase.Db,System.String)">
            <summary>
            确定指定的数据库中是否包含指定名称的表
            </summary>
            <param name="db">数据库对象</param>
            <param name="tableName">表名称</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.IDatabaseMaintainer.AllTables(PinFun.Core.DataBase.Db)">
            <summary>
            返回当前数据库中的所有表清单
            </summary>
            <param name="db">数据库对象</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.ISqlScripts">
            <summary>
            用于存储类型SQL语句的接口
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.ISqlScripts.TableName">
            <summary>
            表名称
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.ISqlScripts.Insert">
            <summary>
            insert语句
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.ISqlScripts.Select">
            <summary>
            查询语句, 不带任何条件
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.SqlScripts`1">
            <summary>
            用于存储类型SQL语句的类
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.Table">
            <summary>
            表定义
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.Table.#ctor">
            <summary>
            新建一个表
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.Table.#ctor(System.Type)">
            <summary>
            用指定的类型新建一个表
            </summary>
            <param name="tableType">表类型</param>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Table.TableType">
            <summary>
            获取当前表所对应的原始CLR类型
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Table.Name">
            <summary>
            表名称
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Table.Columns">
            <summary>
            表中的列集合
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.Table.Indexes">
            <summary>
            该表对应的索引清单, 该字段在Json序列化的时候不会被处理
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.TableIndexAttribute">
            <summary>
            索引类, 默认索引类型为非聚集或普通索引, 默认索引方法为 None, 请注意，某些设置可能是冲突导致没有办法正常生成数据库或者更新数据库
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.TableIndexAttribute.#ctor(System.String[],PinFun.Core.DataBase.Schema.IndexSortBy[])">
            <summary>
            新建一个索引， columns和sortBys的长度必须一致, 默认索引类型为非聚集或普通索引, 默认索引方法为BTree
            </summary>
            <param name="columns">列名称集合</param>
            <param name="sortBys">排序规则集合，此参数可以为NULL，null则全部采用默认的Desc方法</param>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.TableIndexAttribute.IndexName">
            <summary>
            索引名称, 默认名称为 IDX_TN_COLINFO , 其中 _TN_ 表示默认的Table名称，外部程序可以替换该内容为真实的表名称
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.TableIndexAttribute.Columns">
            <summary>
            列信息
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.TableIndexAttribute.Type">
            <summary>
            索引类型, 注意：不同的数据库可能支持的类型不同, 注意，同一个数据库支持的索引类型如果设置有冲突，那么枚举值大的会覆盖枚举值小的
            <example>
            <para>例如：Type=IndexType.Normal | IndexType.Spatial</para>
            <para>那么正在创建的索引类型为 Spatial 因为 Spatial=2 而 Normal=1，故最终创建的类型为 Spatial</para>
            </example>
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.TableIndexAttribute.Method">
            <summary>
            索引方法, 注意：SqlServer不支持该属性
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.TableIndexAttribute.SourceMetaData">
            <summary>
            获取当前索引的原始定义元数据信息
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.TableIndexMetaData">
            <summary>
            表索引信息
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.TableIndexMetaData.IndexName">
            <summary>
            索引名称, 默认名称为 IDX_TN_COLINFO , 其中 _TN_ 表示默认的Table名称，外部程序可以替换该内容为真实的表名称
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.TableIndexMetaData.Columns">
            <summary>
            列信息
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.TableIndexMetaData.Type">
            <summary>
            索引类型, 注意：不同的数据库可能支持的类型不同, 注意，同一个数据库支持的索引类型如果设置有冲突，那么枚举值大的会覆盖枚举值小的
            <example>
            <para>例如：Type=IndexType.Normal | IndexType.Spatial</para>
            <para>那么正在创建的索引类型为 Spatial 因为 Spatial=2 而 Normal=1，故最终创建的类型为 Spatial</para>
            </example>
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.TableIndexMetaData.Method">
            <summary>
            索引方法, 注意：SqlServer不支持该属性
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.IndexSortBy">
            <summary>
            索引列排序规则, MySql不支持该设置
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexSortBy.Asc">
            <summary>
            升序
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexSortBy.Desc">
            <summary>
            降序
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.IndexMethod">
            <summary>
            索引方法, MsSqlServer不支持该设置
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexMethod.None">
            <summary>
            不指定索引方法
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexMethod.Btree">
            <summary>
            BTree算法
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexMethod.Hash">
            <summary>
            Hash算法
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.IndexColumnInfo">
            <summary>
            索引包含列信息
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.IndexColumnInfo.#ctor">
            <summary>
            默认构造函数, 此函数仅供Json反序列化使用，代码中最好不要直接使用
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.IndexColumnInfo.#ctor(System.String,PinFun.Core.DataBase.Schema.IndexSortBy)">
            <summary>
            新建一个索引列
            </summary>
            <param name="name">列名称</param>
            <param name="sortBy">排序规则，默认为降序</param>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.IndexColumnInfo.ColumnName">
            <summary>
            列名称
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.Schema.IndexColumnInfo.SortBy">
            <summary>
            列排序依据, MySql不支持该设置
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.IndexColumnInfo.IsSameWith(PinFun.Core.DataBase.Schema.IndexColumnInfo)">
            <summary>
            判断指定的对象是否和当前对象相同
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.IndexType">
            <summary>
            索引类型
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexType.Fulltext">
            <summary>
            MySql支持的全文检索索引 值=1
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexType.Normal">
            <summary>
            MySql支持的普通索引 值=2
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexType.Spatial">
            <summary>
            MySql和MsSqlServer均支持的空间索引 值=4
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexType.Unique">
            <summary>
            MySql和MsSqlServer均支持的唯一索引 值=8
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexType.NonClustered">
            <summary>
            MsSqlServer支持的非聚集索引 值=16
            </summary>
        </member>
        <member name="F:PinFun.Core.DataBase.Schema.IndexType.Clustered">
            <summary>
            MsSqlServer支持的聚集索引 值=32, 请注意，由于MsSqlServer的主键默认会带有聚集索引，因此如果某个表有主键，然后又包含了一个聚集索引定义可能导致数据库更新或创建失败
            </summary>
        </member>
        <member name="T:PinFun.Core.DataBase.Schema.VersionedTableManager">
            <summary>
            带版本的表管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.VersionedTableManager.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.VersionedTableManager.CheckTableThreeYears(PinFun.Core.DataBase.Schema.Table,System.Int32)">
            <summary>
            从指定给的年份开始，检查3年的表结构，如果成功，那么返回正数，表示成功创建的表数量，否则返回-1
            </summary>
            <param name="table"></param>
            <param name="beginYear"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.VersionedTableManager.OnScheduledTask">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.VersionedTableManager.HasTable(System.String)">
            <summary>
            确定数据库中是否包含指定的表, 此操作通过内部缓存进行，不会真正的去数据库中查询
            </summary>
            <param name="tableName">表名称</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.Schema.VersionedTableManager.GetTable(System.Type)">
            <summary>
            通过CLR类型获取Table定义
            </summary>
            <param name="clrType">CLR类型</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.ScriptHelper.ISqlScriptGenerator">
            <summary>
            Sql脚本生成器
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.ScriptHelper.ISqlScriptGenerator.DbType">
            <summary>
            当前脚本支持的数据库
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.ScriptHelper.ISqlScriptGenerator.GetScriptObject``1">
            <summary>
            获取指定类型对应的脚本对象
            </summary>
            <typeparam name="T">表类型</typeparam>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.ScriptHelper.MsSqlScriptGenerator">
            <summary>
            Ms Sql Server脚本生成器
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.ScriptHelper.MsSqlScriptGenerator.DbType">
            <summary>
            
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.ScriptHelper.MsSqlScriptGenerator.Insert``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DataBase.ScriptHelper.MsSqlScriptGenerator.GetScriptObject``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.ScriptHelper.MySqlScriptGenerator">
            <summary>
            MySql脚本生成器
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.ScriptHelper.MySqlScriptGenerator.DbType">
            <summary>
            
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.ScriptHelper.MySqlScriptGenerator.GetScriptObject``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.ScriptHelper.SqlScriptManager">
            <summary>
            实体类脚本管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.ScriptHelper.SqlScriptManager.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:PinFun.Core.DataBase.ScriptHelper.SqlScriptManager.For(PinFun.Core.DataBase.DbTypes)">
            <summary>
            为指定的数据库类型获取脚本生成器
            </summary>
            <param name="dbType">数据库类型</param>
            <exception cref="T:System.NotSupportedException">暂时不支持数据库</exception>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DataBase.ScriptHelper.SqlScriptObject">
            <summary>
            Sql脚本对象
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.ScriptHelper.SqlScriptObject.Insert">
            <summary>
            当前对象所对应表的插入脚本
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.ScriptHelper.SqlScriptObject.SelectViaPrimaryKey">
            <summary>
            通过主键查询
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.ScriptHelper.SqlScriptObject.UpdateViaPrimaryKey">
            <summary>
            Update语句，默认不更新create三个字段
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.ScriptHelper.SqlScriptObject.TableName">
            <summary>
            当前对象所对应的表名称
            </summary>
        </member>
        <member name="P:PinFun.Core.DataBase.ScriptHelper.SqlScriptObject.PrimaryKeys">
            <summary>
            当前对象对应的表的主键清单
            </summary>
        </member>
        <member name="T:PinFun.Core.DependenceInversion.Config">
            <summary>
            配置信息
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.Config.AutoScan">
            <summary>
            自动扫描
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.Config.DiMaps">
            <summary>
            当前配置的所有DI MAP节点
            </summary>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.Config.GetConfigTemplate">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DependenceInversion.DependenceInversionMap">
            <summary>
            DI Map信息, 配置文件中的实现类如果没有标记版本信息，那么其使用权限最高，否则仍然使用版本号进行检测
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.DependenceInversionMap.Interface">
            <summary>
            接口类型
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.DependenceInversionMap.ImplementType">
            <summary>
            实现类型
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.DependenceInversionMap.IsSingleton">
            <summary>
            是否单实例，默认为false
            </summary>
        </member>
        <member name="T:PinFun.Core.DependenceInversion.DepInvImplementAttribute">
            <summary>
            表示该类型是某个DI接口的实现类
            <para>注意：</para>
            <para>1: 未标记该类型，但实现了相关DI接口的类是不会被识别到的</para>
            <para>2: 被识别的类型可以是public和private两种</para>
            <para>3: 实现类必须具有一个无参构造函数</para>
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.DepInvImplementAttribute.Version">
            <summary>
            实现类版本，如果一个接口有多个实现类，那么除非自己配置，否则的话版本越高越具有优先权
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.DepInvImplementAttribute.SingleInstance">
            <summary>
            表示当前实现类是否为单实例
            </summary>
        </member>
        <member name="T:PinFun.Core.DependenceInversion.DepInvImpMap">
            <summary>
            实现清单
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.DepInvImpMap.InterfaceType">
            <summary>
            DI接口类型
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.DepInvImpMap.Implements">
            <summary>
            实现了该接口的所有类型
            </summary>
        </member>
        <member name="T:PinFun.Core.DependenceInversion.DepInvImpMapItem">
            <summary>
            实现接口定义
            </summary>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.DepInvImpMapItem.TryInitSingleton">
            <summary>
            尝试初始化单实例对象
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.DepInvImpMapItem.ImplementType">
            <summary>
            实现类型
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.DepInvImpMapItem.Version">
            <summary>
            当前实现类的版本
            </summary>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.DepInvImpMapItem.Instance">
            <summary>
            获取当前类的唯一实例
            </summary>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.DepInvImpMapItem.CreateInstance">
            <summary>
            创建当前实现类的实例
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.DependenceInversion.DepInvInterfaceAttribute">
            <summary>
            表示该接口是DI类型，LiteDI将扫描该类型
            </summary>
        </member>
        <member name="T:PinFun.Core.DependenceInversion.LiteDi">
            <summary>
            系统内置的轻量化的DI框架
            <code>配置说明：
            "DependenceInversion":{
                "AutoScan": true,//是否在使用配置的基础之上自动扫描额外的信息
                "DIMaps": [{
                    "Interface": "",
                    "ImplementType": "",
                    "IsSingleton": true //是否单实例
                    }
                ]
            }
            </code>
            </summary>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDi.#ctor">
            <summary>
            系统内置的轻量化的DI框架
            </summary>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDi.InitFromConfig">
            <summary>
            从配置文件初始化列表，并且返回是否自动扫描的配置信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDi.Get``1">
            <summary>
            获取指定接口的实现类
            </summary>
            <typeparam name="T">接口类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDi.Get(System.Type,System.Nullable{System.Double})">
            <summary>
            获取指定类型的实例化对象
            </summary>
            <param name="interfaceType">接口类型</param>
            <param name="targetVersion">目标版本, 如果传null表示获取默认规则下符合条件的版本</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDi.GetAllImplements``1">
            <summary>
            获取某个接口的所有实现类, 返回值可能为NULL
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDi.Map``2">
            <summary>
            向管理器中注册映射关系，添加的类型版本号全部为0，即自动扫描和配置可能覆盖该处代码
            内部无锁，如需要执行添加请在外部确保一开始就运行
            </summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplType">实现类类型</typeparam>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDi.Map``2(``1)">
            <summary>
            向管理器中注册单实例类型，添加的类型版本号全部为0，即自动扫描和配置可能覆盖该处代码
            内部无锁，如需要执行添加请在外部确保一开始就运行
            </summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplType">实现类类型</typeparam>
            <param name="instance">实现类实例</param>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDi.Init">
            <summary>
            初始化，内部无任何业务
            </summary>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDi.InitObject(System.Object)">
            <summary>
            自动实例化某个对象中的<see cref="T:PinFun.Core.DependenceInversion.LiteDiInitializationAttribute"/>标记的对象
            </summary>
            <param name="target">被实例化的对象</param>
        </member>
        <member name="T:PinFun.Core.DependenceInversion.LiteDiInitializationAttribute">
            <summary>
            标记当前变量将通过<see cref="T:PinFun.Core.DependenceInversion.LiteDi"/>进行初始化
            </summary>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDiInitializationAttribute.#ctor">
            <summary>
            采用默认规则初始化
            </summary>
        </member>
        <member name="M:PinFun.Core.DependenceInversion.LiteDiInitializationAttribute.#ctor(System.Double)">
            <summary>
            指定需要初始化的版本
            </summary>
            <param name="version">需要使用的特定版本</param>
        </member>
        <member name="P:PinFun.Core.DependenceInversion.LiteDiInitializationAttribute.Version">
            <summary>
            当前变量所需要的版本, 如果指定的版本没有找到，那么采用默认的规则进行赋值
            </summary>
        </member>
        <member name="T:PinFun.Core.EventSubscription.EventHandlerConfigAttribute">
            <summary>
            事件处理程序配置，默认为非单实例、不影响业务
            </summary>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventHandlerConfigAttribute.#ctor(System.Boolean)">
            <summary>
            事件处理程序配置，默认不影响业务、采用异步方式调用
            </summary>
            <param name="singleton"></param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventHandlerConfigAttribute.#ctor(System.Boolean,System.Boolean)">
            <summary>
            事件处理程序配置
            </summary>
            <param name="singleton">是否使用单实例</param>
            <param name="affectBusiness">是否影响业务</param>
        </member>
        <member name="P:PinFun.Core.EventSubscription.EventHandlerConfigAttribute.Singleton">
            <summary>
            表示该事件处理程序是否是单实例处理程序，如果是的话，那么每一次处理事件将是同一个实例，否则将是一个新实例
            </summary>
        </member>
        <member name="P:PinFun.Core.EventSubscription.EventHandlerConfigAttribute.AffectBusiness">
            <summary>
            获取该处理程序是否需要影响业务，即：如果内部处理出错，是否会导致整个业务出错, 注意，所有不会影响业务的处理器会在影响业务的处理器完成处理之后被调用
            </summary>
        </member>
        <member name="T:PinFun.Core.EventSubscription.EventHandlerMetaData">
            <summary>
            事件处理程序元数据
            </summary>
        </member>
        <member name="P:PinFun.Core.EventSubscription.EventHandlerMetaData.HandlerType">
            <summary>
            事件处理程序类型
            </summary>
        </member>
        <member name="P:PinFun.Core.EventSubscription.EventHandlerMetaData.Method">
            <summary>
            对应的方法
            </summary>
        </member>
        <member name="T:PinFun.Core.EventSubscription.AfterRaiseEvent">
            <summary>
            在触发事件之后触发的事件
            </summary>
            <param name="event">具体的事件对象</param>
        </member>
        <member name="T:PinFun.Core.EventSubscription.EventSubscriptManager">
            <summary>
            事件订阅管理器, 除OnAfterRaiseEvent事件外，所有的事件订阅程序执行线程和触发线程相同
            </summary>    
        </member>
        <member name="F:PinFun.Core.EventSubscription.EventSubscriptManager._manualEventSubscribers">
            <summary>
            手工订阅事件 事件类型 - 订阅者列表
            </summary>
        </member>
        <member name="F:PinFun.Core.EventSubscription.EventSubscriptManager._eventSubscriptMap">
            <summary>
            事件订阅关系映射, 事件类型--事件处理程序清单
            </summary>
        </member>
        <member name="F:PinFun.Core.EventSubscription.EventSubscriptManager._singletonHandler">
            <summary>
            所有单实例处理程序列表 处理程序类型--实例
            </summary>
        </member>
        <member name="F:PinFun.Core.EventSubscription.EventSubscriptManager._handlerConfig">
            <summary>
            所有扫描到的处理程序配置，如果没有找到那么采用默认配置 处理程序类型--配置
            </summary>
        </member>
        <member name="F:PinFun.Core.EventSubscription.EventSubscriptManager._defaultConfig">
            <summary>
            默认的事件处理程序配置
            </summary>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.#ctor">
            <summary>
            事件订阅管理器
            </summary>
        </member>
        <member name="E:PinFun.Core.EventSubscription.EventSubscriptManager.OnAfterRaiseEvent">
            <summary>
            在内部触发事件之后，会调用的方法, 该方法会被另起线程调用，任何处理代码异常将不会影响后续流程执行
            </summary>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.RaiseEvent``1(``0)">
            <summary>
            触发事件, 如果当前调用是在事务环境下，那么仅有影响业务的处理器会被立即调用，其他不影响业务的将等到事务提交成功之后才会被调用，所有不影响业务的处理程序将自动被放到新线程中调用
            </summary>
            <typeparam name="TEvent">被触发的事件类型</typeparam>
            <param name="event">事件数据</param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.RaiseNotAffectBusinessEvent``1(``0)">
            <summary>
            内部调用，其仅触发不影响业务的处理, 在事务被提交之后调用
            </summary>
            <typeparam name="TEvent"></typeparam>
            <param name="event"></param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.TriggerAutoEventSubscriberHandler``1(``0,System.Boolean,System.Boolean)">
            <summary>
            触发自动扫描而来的事件订阅处理程序
            </summary>
            <typeparam name="TEvent"></typeparam>
            <param name="event"></param>
            <param name="callAffectBusiness">触发影响业务的逻辑</param>
            <param name="callNotAffectBusiness">触发不影响业务的逻辑</param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.GetHandler(System.Type,PinFun.Core.EventSubscription.EventHandlerConfigAttribute)">
            <summary>
            获取某个处理程序的实例
            </summary>
            <param name="handlerType"></param>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.InvokeHandler(PinFun.Core.EventSubscription.EventHandlerMetaData,System.Object,PinFun.Core.EventSubscription.ISubscriptionEvent,PinFun.Core.EventSubscription.EventHandlerConfigAttribute)">
            <summary>
            调用某个事件的处理程序
            </summary>
            <param name="metaData"></param>
            <param name="handler"></param>
            <param name="event"></param>
            <param name="config"></param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.AnalyzeHandlerType(System.Type)">
            <summary>
            分析某个类型是否是合理的订阅类
            </summary>
            <param name="handlerType"></param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.InvokeAfterRaiseEvent(PinFun.Core.EventSubscription.ISubscriptionEvent)">
            <summary>
            触发OnAfterRaiseEvent事件
            </summary>
            <param name="event"></param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.GetEventSubscriberList(System.Type)">
            <summary>
            从缓存列表中获取指定订阅事件的处理程序清单对象
            </summary>
            <param name="eventType"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.Subscribe``1(PinFun.Core.EventSubscription.IEventSubscriber{``0})">
            <summary>
            手动订阅事件
            </summary>
            <typeparam name="TEvent">待订阅的事件类型</typeparam>
            <param name="eventSubscriber">订阅者</param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.UnSubscribe``1(PinFun.Core.EventSubscription.IEventSubscriber{``0})">
            <summary>
            取消订阅事件
            </summary>
            <typeparam name="TEvent">已订阅的事件类型</typeparam>
            <param name="eventSubscriber">订阅者</param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.EventSubscriptManager.TriggerManualEventSubscriberHandler(System.Object,System.Boolean,System.Boolean)">
            <summary>
            触发手工事件订阅处理程序
            </summary>
            <param name="event">事件对象</param>
            <param name="callAffectBusiness">调用影响业务的逻辑</param>
            <param name="callNotAffectBusiness">调用不影响业务的逻辑</param>
        </member>
        <member name="T:PinFun.Core.EventSubscription.IEventSubscriber`1">
            <summary>
            手工订阅者需要实现的接口, 如果订阅程序影响业务，那么在业务执行线程上同步执行，如果不影响业务，那么在单独的线程中执行
            </summary>
            <typeparam name="TEvent">被订阅的事件类型</typeparam>
        </member>
        <member name="M:PinFun.Core.EventSubscription.IEventSubscriber`1.Process(`0)">
            <summary>
            处理事件
            </summary>
            <param name="event"></param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.IEventSubscriber`1.IsAffectBusinessForEvent(`0)">
            <summary>
            当前处理程序是否影响业务
            </summary>
            <param name="event"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.EventSubscription.IManualEventSubscriberInvokeHelper">
            <summary>
            基于手工事件订阅的订阅程序调用助手对象接口
            </summary>
        </member>
        <member name="P:PinFun.Core.EventSubscription.IManualEventSubscriberInvokeHelper.Subscriber">
            <summary>
            原始订阅者
            </summary>
        </member>
        <member name="M:PinFun.Core.EventSubscription.IManualEventSubscriberInvokeHelper.Process(log4net.ILog,System.Object)">
            <summary>
            触发该订阅者的处理事件
            </summary>
            <param name="log">用于记录错误日志的对象</param>
            <param name="event">待发送的事件对象</param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.IManualEventSubscriberInvokeHelper.IsAffectBusinessForEvent(System.Object)">
            <summary>
            针对特定事件是否影响业务
            </summary>
            <param name="event"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.EventSubscription.InvokeInfo">
            <summary>
            临时的事件触发信息
            </summary>
        </member>
        <member name="T:PinFun.Core.EventSubscription.ISubscriptionEvent">
            <summary>
            所有被可被订阅的事件均需要实现该接口
            </summary>
        </member>
        <member name="T:PinFun.Core.EventSubscription.ISubscriptionEventHandler`1">
            <summary>
            事件处理程序, 内部自动依据当前处理器是否影响业务进行不同的调用，影响业务，在主调用线程上执行（同步），不影响业务，采用单独线程执行，处理器处理时长不会影响主业务调用时长
            <para>可以通过<see cref="T:PinFun.Core.EventSubscription.EventHandlerConfigAttribute"/>配置相关handler属性</para>
            </summary>
            <typeparam name="TEvent">具体需要触发的事件类型</typeparam>
        </member>
        <member name="M:PinFun.Core.EventSubscription.ISubscriptionEventHandler`1.HandlerEvent(`0)">
            <summary>
            处理事件
            </summary>
            <param name="event"></param>
        </member>
        <member name="T:PinFun.Core.EventSubscription.ManualEventSubscriberInvokeHelper`1">
            <summary>
            基于手工事件订阅的调用处理程序实现类
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:PinFun.Core.EventSubscription.ManualEventSubscriberList">
            <summary>
            手工事件订阅者清单
            </summary>
        </member>
        <member name="M:PinFun.Core.EventSubscription.ManualEventSubscriberList.Add``1(PinFun.Core.EventSubscription.IEventSubscriber{``0})">
            <summary>
            向订阅者清单中增加订阅者
            </summary>
            <param name="subscriber">订阅者对象</param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.ManualEventSubscriberList.Remove``1(PinFun.Core.EventSubscription.IEventSubscriber{``0})">
            <summary>
            移除订阅者清单中的指定订阅者
            </summary>
            <param name="subscriber">订阅者对象</param>
        </member>
        <member name="M:PinFun.Core.EventSubscription.ManualEventSubscriberList.GetAllHelpers">
            <summary>
            获取指定类型的所有订阅帮助对象
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.EventSubscription.RemoteEvent">
            <summary>
            服务器上的事件订阅
            </summary>
        </member>
        <member name="M:PinFun.Core.EventSubscription.RemoteEvent.Subscribe``1">
            <summary>
            在默认的名为default的服务器上订阅事件
            </summary>
            <typeparam name="T">待订阅的事件类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.EventSubscription.RemoteEvent.On(System.String)">
            <summary>
            在指定名称的服务器上订阅远程事件
            </summary>
            <param name="serverName">服务器名称</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.EventSubscription.RemoteEvent.On(PinFun.Core.Api.ApiProxy.IInvokeTunnel)">
            <summary>
            在指定的远程调用通道上订阅远程事件
            </summary>
            <param name="tunnel">远程通道对象</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.EventSubscription.RemoteEventOnTunnel">
            <summary>
            远程订阅管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.EventSubscription.RemoteEventOnTunnel.Subscribe``1">
            <summary>
            订阅事件, 订阅之后，如果收到了服务器下发的事件，将通过类似于 EventSubscriptManager.RaiseEvent 方法触发
            </summary>
            <typeparam name="T">被订阅的事件类型</typeparam>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.EventSubscription.RemoteEventSubscriptManager">
            <summary>
            内置的远程事件订阅处理器
            </summary>
        </member>
        <member name="T:PinFun.Core.License.ClientLicenseFeature">
            <summary>
            客户端的license扩展功能读取程序, 目前直接最大化允许
            </summary>
        </member>
        <member name="M:PinFun.Core.License.ClientLicenseFeature.HasLiteService(System.Guid)">
            <summary>
            
            </summary>
            <param name="serviceId"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.License.ILicenseFeature">
            <summary>
            授权license中所包含的扩展信息读取功能
            </summary>
        </member>
        <member name="M:PinFun.Core.License.ILicenseFeature.HasLiteService(System.Guid)">
            <summary>
            当前License中是否包含指定的轻服务授权
            </summary>
            <param name="serviceId">轻服务编号</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.License.LicenseInfo">
            <summary>
            license信息
            </summary>
        </member>
        <member name="M:PinFun.Core.License.LicenseInfo.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="P:PinFun.Core.License.LicenseInfo.IsTrial">
            <summary>
            是否是试用版的license
            </summary>
        </member>
        <member name="P:PinFun.Core.License.LicenseInfo.TrialEnd">
            <summary>
            试用结束日期
            </summary>
        </member>
        <member name="P:PinFun.Core.License.LicenseInfo.HardwareId">
            <summary>
            当前license授权的硬件编号
            </summary>
        </member>
        <member name="P:PinFun.Core.License.LicenseInfo.Issuer">
            <summary>
            签发给
            </summary>
        </member>
        <member name="P:PinFun.Core.License.LicenseInfo.ExtraInfo">
            <summary>
            license中的扩展信息
            </summary>
        </member>
        <member name="T:PinFun.Core.License.LicenseInfoStoreInfo">
            <summary>
            license对应的存储信息
            </summary>
        </member>
        <member name="P:PinFun.Core.License.LicenseInfoStoreInfo.Signature">
            <summary>
            签名信息
            </summary>
        </member>
        <member name="T:PinFun.Core.License.LicenseManager">
            <summary>
            License管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.License.LicenseManager.SetLicenseFeature(PinFun.Core.License.ILicenseFeature)">
            <summary>
            设置当前license的扩展信息读取器，针对服务器而言，需要进行完善的权限控制，针对客户端而言，可能无需license控制
            </summary>
            <param name="licenseFeature"></param>
        </member>
        <member name="P:PinFun.Core.License.LicenseManager.Features">
            <summary>
            License中的扩展信息读取器
            </summary>
        </member>
        <member name="E:PinFun.Core.License.LicenseManager.LicenseChanged">
            <summary>
            当License发生变更时候触发
            </summary>
        </member>
        <member name="M:PinFun.Core.License.LicenseManager.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="M:PinFun.Core.License.LicenseManager.#ctor">
            <summary>
            新建一个管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.License.LicenseManager.GetHardwareId">
            <summary>
            获取硬件编号
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.License.LicenseManager.GetCupId">
            <summary>
            获取当前计算机的CPU编号
            </summary>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.License.LicenseManager.Current">
            <summary>
            获取当前服务器上对应的有效license
            </summary>
        </member>
        <member name="M:PinFun.Core.License.LicenseManager.GetLicenseFrom(System.String)">
            <summary>
            从指定的文件中读取License信息
            </summary>
            <param name="licenseFile"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.License.LicenseManager.GetExtraInfoInLicense``1(PinFun.Core.License.LicenseInfo,System.String)">
            <summary>
            获取license中存储的指定类型的数据
            </summary>
            <typeparam name="T">需要返回的内容</typeparam>
            <param name="license">license对象</param>
            <param name="key">扩展存储字段名称， 注意: 区分大小写</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.License.LicenseManager.GetExtraInfoInLicense``1(System.String)">
            <summary>
            获取当前程序域下默认license中存储的信息
            </summary>
            <typeparam name="T">待获取数据的联系</typeparam>
            <param name="key">扩展存储字段名称， 注意: 区分大小写</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.License.LicenseManager.CheckLicense(System.Action{System.Int32})">
            <summary>
            校验当前程序目录下的license
            </summary>
            <param name="inValidCallBack">license无效的回调函数</param>
        </member>
        <member name="T:PinFun.Core.License.TrialEndChecker">
            <summary>
            试用版的License检查工具
            </summary>
        </member>
        <member name="T:PinFun.Core.LiteService.ILiteService">
            <summary>
            轻量级服务，该服务会在所有<see cref="T:PinFun.Core.Worker.AutoStartWorker`1"/>之后，<see cref="T:PinFun.Core.ServiceHost.IServiceHost"/>之前被启动，所有轻服务必须具有无参构造函数
            <para>注意：所有的轻服务可以被用户通过控制面板进行关闭，如果不想用户可以关闭，可以使用<see cref="T:PinFun.Core.Worker.AutoStartWorker`1"/>代替</para>
            </summary>
        </member>
        <member name="P:PinFun.Core.LiteService.ILiteService.ServiceId">
            <summary>
            当前服务的编号，用于控制
            </summary>
        </member>
        <member name="P:PinFun.Core.LiteService.ILiteService.Description">
            <summary>
            当前服务的描述信息
            </summary>
        </member>
        <member name="P:PinFun.Core.LiteService.ILiteService.Name">
            <summary>
            服务名称
            </summary>
        </member>
        <member name="M:PinFun.Core.LiteService.ILiteService.Start">
            <summary>
            启动
            </summary>
        </member>
        <member name="M:PinFun.Core.LiteService.ILiteService.Stop">
            <summary>
            停止
            </summary>
        </member>
        <member name="T:PinFun.Core.LiteService.LiteServiceManager">
            <summary>
            轻服务<see cref="T:PinFun.Core.LiteService.ILiteService"/>管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.LiteService.LiteServiceManager.#ctor">
            <summary>
            新建轻服务<see cref="T:PinFun.Core.LiteService.ILiteService"/>管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.LiteService.LiteServiceManager.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:PinFun.Core.LiteService.LiteServiceManager.InvInit">
            <summary>
            反初始化
            </summary>
        </member>
        <member name="M:PinFun.Core.LiteService.LiteServiceManager.Start(System.Guid)">
            <summary>
            启动服务
            </summary>
            <param name="serviceId"></param>
        </member>
        <member name="M:PinFun.Core.LiteService.LiteServiceManager.Stop(System.Guid)">
            <summary>
            停止服务
            </summary>
            <param name="serviceId"></param>
        </member>
        <member name="M:PinFun.Core.LiteService.LiteServiceManager.AllServiceInfo">
            <summary>
            获取当前系统中扫描到的所有服务信息
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.LiteService.LiteServiceRuntimeInfo">
            <summary>
            轻服务运行信息
            </summary>
        </member>
        <member name="M:PinFun.Core.LiteService.LiteServiceRuntimeInfo.#ctor">
            <summary>
            该构造函数仅供通过反射创建对象使用，外部程序不应该主动调用该函数创建对象
            </summary>
        </member>
        <member name="P:PinFun.Core.LiteService.LiteServiceRuntimeInfo.Service">
            <summary>
            服务实例
            </summary>
        </member>
        <member name="P:PinFun.Core.LiteService.LiteServiceRuntimeInfo.Status">
            <summary>
            当前服务状态
            </summary>
        </member>
        <member name="P:PinFun.Core.LiteService.LiteServiceRuntimeInfo.Name">
            <summary>
            服务名称
            </summary>
        </member>
        <member name="P:PinFun.Core.LiteService.LiteServiceRuntimeInfo.Description">
            <summary>
            服务描述
            </summary>
        </member>
        <member name="P:PinFun.Core.LiteService.LiteServiceRuntimeInfo.ServiceId">
            <summary>
            服务编号
            </summary>
        </member>
        <member name="T:PinFun.Core.LiteService.LiteServiceStatus">
            <summary>
            轻服务状态
            </summary>
        </member>
        <member name="F:PinFun.Core.LiteService.LiteServiceStatus.Starting">
            <summary>
            启动中
            </summary>
        </member>
        <member name="F:PinFun.Core.LiteService.LiteServiceStatus.Running">
            <summary>
            运行中
            </summary>
        </member>
        <member name="F:PinFun.Core.LiteService.LiteServiceStatus.Stopping">
            <summary>
            正在停止
            </summary>
        </member>
        <member name="F:PinFun.Core.LiteService.LiteServiceStatus.Stopped">
            <summary>
            已经停止
            </summary>
        </member>
        <member name="F:PinFun.Core.LiteService.LiteServiceStatus.Failed">
            <summary>
            错误
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Common.ConnectionSession">
            <summary>
            某个连接上的Session数据
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.ConnectionSession.Item(System.String)">
            <summary>
            获取或者设置一个session数据
            </summary>
            <param name="name">session名称</param>
        </member>
        <member name="M:PinFun.Core.Net.Common.ConnectionSession.ContainsKey(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Net.Common.Started">
            <summary>
            服务器启动完成之后触发
            </summary>
            <param name="server"></param>
        </member>
        <member name="T:PinFun.Core.Net.Common.Stopped">
            <summary>
            服务器停止关闭之后触发
            </summary>
            <param name="server"></param>
        </member>
        <member name="T:PinFun.Core.Net.Common.NewConnection">
            <summary>
            服务器端接收到了的新的连接请求
            </summary>
            <param name="server">服务器对象</param>
            <param name="clientConnection">客户端连接对象</param>
        </member>
        <member name="T:PinFun.Core.Net.Common.DisConnected">
            <summary>
            客户端的连接断开
            </summary>
            <param name="server">服务器对象</param>
            <param name="clientConnection">客户端连接对象</param>
        </member>
        <member name="T:PinFun.Core.Net.Common.Connected">
            <summary>
            当前客户端和服务器的连接恢复或者连接上
            </summary>
            <param name="client">客户端</param>
        </member>
        <member name="T:PinFun.Core.Net.Common.ServerDisConnected">
            <summary>
            和服务器的连接中断事件
            </summary>
            <param name="client">客户端</param>
        </member>
        <member name="T:PinFun.Core.Net.Common.IClient">
            <summary>
            客户端需要实现的接口
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.IClient.Name">
            <summary>
            客户端名称
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.IClient.ServerAddress">
            <summary>
            服务器信息
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.IClient.Port">
            <summary>
            服务器端口
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.IClient.IsConnected">
            <summary>
            是否已经连上服务器
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Common.IClient.OnServerConnected">
            <summary>
            和服务器建立连接事件
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Common.IClient.OnServerDisConnected">
            <summary>
            和服务器的连接中断事件
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Common.IClient.Open">
            <summary>
            打开连接
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Common.IClient.Close">
            <summary>
            关闭连接
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Common.IConnection">
            <summary>
            连接对象
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.IConnection.Session">
            <summary>
            当前连接上的Session数据，用户可以自行在上面存放东西，该数据不会传递到客户端
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Common.IConnection.Send(System.Object)">
            <summary>
            向客户端发送数据
            </summary>
            <param name="data">待发送的数据</param>
        </member>
        <member name="P:PinFun.Core.Net.Common.IConnection.RemoteAddress">
            <summary>
            获取当前连接对应的远程地址信息
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.IConnection.ConnectionId">
            <summary>
            当前连接的连接ID
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Common.IConnection.Close">
            <summary>
            关闭连接
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Net.Common.IServer">
            <summary>
            服务器需要实现的接口
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Common.IServer.OnStarted">
            <summary>
            在服务器启动之后触发
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Common.IServer.OnStopped">
            <summary>
            在服务器关闭之后触发
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Common.IServer.OnNewConnection">
            <summary>
            当接受到新的连接请求时候触发
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Common.IServer.OnDisConnected">
            <summary>
            当客户端与服务器的连接断开时触发
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.IServer.AllConnections">
            <summary>
            获取当前发起中的所有客户端连接对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Common.IServer.BoardCase(System.Byte[])">
            <summary>
            向当前服务器上的所有客户端广播数据
            </summary>
            <param name="data">待发送的数据</param>
        </member>
        <member name="T:PinFun.Core.Net.Common.ISession">
            <summary>
            Session对象接口
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.ISession.Item(System.String)">
            <summary>
            获取或者设置Session对象中的数据
            </summary>
            <param name="name">session key名称</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Common.ISession.ContainsKey(System.String)">
            <summary>
            确认当前Session中是否包含指定的name
            </summary>
            <param name="name">session key名称</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Net.Common.TlsCertificateInfo">
            <summary>
            加密信息
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.TlsCertificateInfo.CertificateFile">
            <summary>
            加密证书路径
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.TlsCertificateInfo.Password">
            <summary>
            证书密码
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Common.TlsCertificateInfo.IsPasswordEncrypted">
            <summary>
            当前证书密码是否已经加密，如果加密，将采用<see cref="T:PinFun.Core.DataBase.DbManager"/>中的Decrypt方法进行解密
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Http.Cookie">
            <summary>
            HTTP Cookie
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.Cookie.#ctor(System.String,System.String)">
            <summary>
            新建一个Cookie
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:PinFun.Core.Net.Http.Cookie.#ctor(System.String,System.String,PinFun.Core.Net.Http.CookieOptions)">
            <summary>
            新建一个Cookie
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="cookieOptions"></param>
        </member>
        <member name="P:PinFun.Core.Net.Http.Cookie.Key">
            <summary>
            当前Cookie的Key
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.Cookie.Value">
            <summary>
            当前Cookie的值
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.Cookie.ToString">
            <summary>
            在Header中的值
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Net.Http.CookieOptions">
            <summary>
            HTTP Cookie配置
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.CookieOptions.Domain">
            <summary>
            字段为可以访问此cookie的域名
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.CookieOptions.Path">
            <summary>
            字段为可以访问此cookie的页面路径。 比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie。
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.CookieOptions.Expires">
            <summary>
            字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.CookieOptions.Secure">
            <summary>
             设置是否只能通过https来传递此条cookie
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.CookieOptions.HttpOnly">
            <summary>
            cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.CookieOptions.ToString">
            <summary>
            属性字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Net.Http.CookieCollection">
            <summary>
            Cookie集合
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.CookieCollection.ContainsKey(System.String)">
            <summary>
            确定集合中公司否包含某个指定名称的cookie
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Net.Http.CookieCollection.Item(System.String)">
            <summary>
            获取指定名称的Cookie对象, 获取到的对象仅包含值，属性部分数据无效
            </summary>
            <param name="name">cookie名称</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Net.Http.HttpContext">
            <summary>
            HTTP请求上下文对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpContext.#ctor(DotNetty.Codecs.Http.IFullHttpRequest,PinFun.Core.Net.Common.IConnection,System.String,PinFun.Core.Net.Http.IHttpSessionProvider)">
            <summary>
            新建一个HTTP请求上下文对象
            </summary>
            <param name="request">原始请求对象</param>
            <param name="connection">原始连接对象</param>
            <param name="serverName">用于传递到客户端的服务器名称</param>
            <param name="sessionProvider">Session存储提供程序</param>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpContext.Request">
            <summary>
            请求
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpContext.Response">
            <summary>
            返回
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpContext.IsKeepAlive">
            <summary>
            是否保持连接
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Http.HttpRequest">
            <summary>
            HTTP请求
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpRequest.#ctor(DotNetty.Codecs.Http.IFullHttpRequest,PinFun.Core.Net.Http.IHttpSessionProvider)">
            <summary>
            新建一个HTTP的请求
            </summary>
            <param name="sourceRequest">原始请求对象</param>
            <param name="sessionProvider">session存储提供程序</param>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpRequest.Headers">
            <summary>
            请求头
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpRequest.Method">
            <summary>
            请求方法
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpRequest.Uri">
            <summary>
            请求地址
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpRequest.ContentType">
            <summary>
            当前请求的内容类型
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpRequest.QueryString">
            <summary>
            获取该请求的所有查询参数
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpRequest.SourceRequest">
            <summary>
            获取原始的请求对象
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpRequest.File">
            <summary>
            获取当前请求的文件，不包含参数部分
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpRequest.Body">
            <summary>
            当前请求的请求Body内容
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpRequest.Cookies">
            <summary>
            获取当前请求的所有Cookie集合
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpRequest.Session">
            <summary>
            Session对象
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Http.HttpResponse">
            <summary>
            HTTP输出对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.SendResponseHeader">
            <summary>
            发送响应头
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.SetHttpResponseStatus(DotNetty.Codecs.Http.HttpResponseStatus)">
            <summary>
            设置当前响应代码
            </summary>
            <param name="code">响应代码</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.SetContentType(System.String)">
            <summary>
            设置响应内容类型
            </summary>
            <param name="contentType">内容类型</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.SetContentLength(System.Int64)">
            <summary>
            自定义响应内容长度
            </summary>
            <param name="contentLength">内容长度</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.AddCookie(PinFun.Core.Net.Http.Cookie)">
            <summary>
            向当前请求中写入Cookie内容, 注意Cookie的必须在所有的Write方法调用之前进行,否则cookie可能无法写入到客户端
            </summary>
            <param name="cookie"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.Write(System.String,System.Text.Encoding)">
            <summary>
            向当前输出中写入文本信息，注意，最后一次写入的数据将在调用<see cref="M:PinFun.Core.Net.Http.HttpResponse.End"/>方法时候写出
            </summary>
            <param name="content">文本内容</param>
            <param name="encoding">编码方式</param>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.Write(System.String)">
            <summary>
            向当前输出中写入文本信息, 编码方式为UTF-8，注意，最后一次写入的数据将在调用<see cref="M:PinFun.Core.Net.Http.HttpResponse.End"/>方法时候写出
            </summary>
            <param name="content">文本内容</param>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.Write(System.Byte[])">
            <summary>
            向当前输出中写入数据，注意，最后一次写入的数据将在调用<see cref="M:PinFun.Core.Net.Http.HttpResponse.End"/>方法时候写出
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.SetHeader(System.String,System.String)">
            <summary>
            向返回值中写入Header信息
            </summary>
            <param name="name">名称</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.SetHeader(DotNetty.Common.Utilities.AsciiString,System.String)">
            <summary>
            向返回值中写入Header信息
            </summary>
            <param name="asciiName">名称</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpResponse.End">
            <summary>
            完成输出
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Http.HttpServer">
            <summary>
            WEB服务器
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.#ctor(System.Int32,System.String,System.Boolean,System.Int32)">
            <summary>
            在指定的端口新建一个Web服务器
            </summary>
            <param name="port"></param>
            <param name="name"></param>
            <param name="enableDotNettyLog">是否启用DotNetty日志</param>
            <param name="maxContentLength">请求最大值, 单位 kB, 如果传小于等于0的值，则使用内部默认为1024, 即1M</param>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.SetSessionProvider(PinFun.Core.Net.Http.IHttpSessionProvider)">
            <summary>
            设置当前服务器所使用的Session存储提供程序
            </summary>
            <param name="sessionProvider">session存储提供程序</param>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpServer.EnableDotNettyLog">
            <summary>
            是否启用DotNetty日志
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpServer.EnableHeartbeatCheck">
            <summary>
            不启用心跳
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.BuildClientChannel(DotNetty.Transport.Channels.IChannelPipeline)">
            <summary>
            
            </summary>
            <param name="clientChannelPipeline"></param>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.DataReceived(PinFun.Core.Net.Common.IConnection,System.Object)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <param name="data"></param>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.OnException(PinFun.Core.Net.Common.IConnection,System.Exception)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <param name="ex"></param>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.NewConnection(PinFun.Core.Net.Common.IConnection)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.GetLogger">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.OnRequest(PinFun.Core.Net.Http.HttpContext)">
            <summary>
            执行请求
            </summary>
            <param name="context">请求上下文对象</param>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.ConfigServer(System.Action{PinFun.Core.Net.Http.HttpServerAppBuilder})">
            <summary>
            配置当前服务器
            </summary>
            <param name="appBuilder">服务器处理器</param>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.ServerName">
            <summary>
            获取当前服务器的名称和版本
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.SetChildTcpOption(DotNetty.Transport.Bootstrapping.ServerBootstrap)">
            <summary>
            
            </summary>
            <param name="bootstrap"></param>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServer.WhenIdle(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Handlers.Timeout.IdleStateEvent)">
            <summary>
            http服务器，只要读取数据超时，那么关闭连接
            </summary>
            <param name="context"></param>
            <param name="idleStateEvent"></param>
        </member>
        <member name="T:PinFun.Core.Net.Http.HttpServerAppBuilder">
            <summary>
            WEB APP Builder
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServerAppBuilder.Use``1">
            <summary>
            向当前中间件中增加处理程序
            </summary>
            <typeparam name="TMiddleware">处理程序类型</typeparam>
            <returns>返回当前对象</returns>
        </member>
        <member name="M:PinFun.Core.Net.Http.HttpServerAppBuilder.Finish(PinFun.Core.Net.Http.WebMiddleware,log4net.ILog)">
            <summary>
            添加最后一个类型，并且完成内部初始化
            </summary>
            <param name="last"></param>
            <param name="log"></param>
        </member>
        <member name="P:PinFun.Core.Net.Http.HttpServerAppBuilder.FirstMiddleware">
            <summary>
            获取当前处理程序中的第一个
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Http.IHttpSessionProvider">
            <summary>
            Session存储提供程序接口
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.IHttpSessionProvider.GetConnectionSession(System.String)">
            <summary>
            获取指定连接上的Session对象
            </summary>
            <param name="connectionId">连接编号</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Net.Http.MemorySessionProvider">
            <summary>
            基于内存存储的Session存储提供程序
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Http.MemorySessionItem">
            <summary>
            内存中的Session存储单位
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.MemorySessionItem.#ctor(System.Int32)">
            <summary>
            新建一个存储单位
            </summary>
            <param name="expireTime">该存储单位的超时时间，单位为：分钟</param>
        </member>
        <member name="P:PinFun.Core.Net.Http.MemorySessionItem.Session">
            <summary>
            存放数据的对象
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.MemorySessionItem.IsExpired">
            <summary>
            获取当前Session单位是否已经过期
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.MemorySessionItem.Delay(System.Int32)">
            <summary>
            将当前Session在延期指定时间
            </summary>
            <param name="minutes"></param>
        </member>
        <member name="T:PinFun.Core.Net.Http.Middlewares.DefaultMiddleware">
            <summary>
            默认的WEB中间件， 该中间件将返回当前服务器的时间
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.Middlewares.DefaultMiddleware.#ctor(PinFun.Core.Net.Http.WebMiddleware)">
            <summary>
            新建一个默认的中间件
            </summary>
            <param name="next"></param>
        </member>
        <member name="T:PinFun.Core.Net.Http.MultipartForm.MultipartFormFileItem">
            <summary>
            MultipartForm文件域
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormFileItem.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},PinFun.Core.Net.Http.MultipartForm.MultipartFormItemSourceInfo)">
            <summary>
            MultipartForm 文件域
            </summary>
            <param name="contentDisposition"></param>
            <param name="source"></param>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormFileItem.FileName">
            <summary>
            当前文件的名称
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormFileItem.ContentType">
            <summary>
            文件类型
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormFileItem.FileData">
            <summary>
            文件数据
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormFileItem.Type">
            <inheritdoc />
        </member>
        <member name="T:PinFun.Core.Net.Http.MultipartForm.MultipartFormItem">
            <summary>
            MultipartForm 条目
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormItem.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},PinFun.Core.Net.Http.MultipartForm.MultipartFormItemSourceInfo)">
            <summary>
            MultipartForm 条目
            </summary>
            <param name="contentDisposition">Content-Disposition</param>
            <param name="source"></param>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormItem.Name">
            <summary>
            当前域的名称
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormItem.ConvertItem(PinFun.Core.Net.Http.MultipartForm.MultipartFormItemSourceInfo)">
            <summary>
            将原始字符串转换为对象
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormItem.To``1">
            <summary>
            将当前项转换为其他指定类型的项
            </summary>
            <typeparam name="TItem">目标项</typeparam>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormItem.Type">
            <summary>
            获取当前项目类型
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Http.MultipartForm.MultipartFormItemSourceInfo">
            <summary>
            原始项定义
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormItemSourceInfo.#ctor(System.Byte[])">
            <summary>
            原始项定义
            </summary>
            <param name="partInfo">当前项目的原始数据</param>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormItemSourceInfo.From(System.Byte[])">
            <summary>
            从字节数组获取MultipartFormItemSourceInfo定义，如果partInfo.length=0则返回null
            </summary>
            <param name="partInfo"></param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormItemSourceInfo.Headers">
            <summary>
            头部定义 
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormItemSourceInfo.Body">
            <summary>
            数据
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Http.MultipartForm.MultipartFormItemType">
            <summary>
            MultipartFormItem 类型
            </summary>
        </member>
        <member name="F:PinFun.Core.Net.Http.MultipartForm.MultipartFormItemType.Text">
            <summary>
            文本
            </summary>
        </member>
        <member name="F:PinFun.Core.Net.Http.MultipartForm.MultipartFormItemType.File">
            <summary>
            文件
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader">
            <summary>
            MultipartForm读取
            </summary>
        </member>
        <member name="F:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.RnByte">
            <summary>
            换行标记
            </summary>
        </member>
        <member name="F:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.HeaderBodySeparator">
            <summary>
            头部和数据部分的分割标记
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.TryRead(PinFun.Core.Net.Http.HttpRequest,PinFun.Core.Net.Http.MultipartForm.MultipartFormReader@)">
            <summary>
            尝试从当前请求中使用MultipartForm方式读取数据
            </summary>
            <param name="request"></param>
            <param name="multipartForm"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.#ctor(PinFun.Core.Net.Http.HttpRequest,System.String)">
            <summary>
            提供基于Owin请求的MultipartForm读取功能, 必须调用<see cref="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.Process"/>方法之后才能读取数据
            </summary>
            <param name="request">请求</param>
            <param name="boundary">分隔符</param>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.Process">
            <summary>
            处理当前上下文, 处理之后可能无法再从Request.Body中读取数据
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.GetFormItem(System.String)">
            <summary>
            获取指定名称的条目原始定义
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.SourceString">
            <summary>
            当前客户端提交的原始字符串
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.Keys">
            <summary>
            获取当前表单中的所有字段名称
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.AllItems">
            <summary>
            获取当前表单的所有项列表
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormReader.Item(System.String)">
            <summary>
            获取指定名称的项
            </summary>
            <param name="name">字段名称</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Net.Http.MultipartForm.MultipartFormTextItem">
            <summary>
            MultipartForm 文本域
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.MultipartForm.MultipartFormTextItem.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},PinFun.Core.Net.Http.MultipartForm.MultipartFormItemSourceInfo)">
            <summary>
            MultipartForm 文本域
            </summary>
            <param name="contentDisposition"></param>
            <param name="source"></param>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormTextItem.Value">
            <summary>
            当前文本域的值
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Http.MultipartForm.MultipartFormTextItem.Type">
            <inheritdoc />
        </member>
        <member name="T:PinFun.Core.Net.Http.WebMiddleware">
            <summary>
            Web请求中间件
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.WebMiddleware.#ctor(PinFun.Core.Net.Http.WebMiddleware)">
            <summary>
            新建一个WEB中间件
            </summary>
            <param name="next">该WEB中间件的下一个中间件</param>
        </member>
        <member name="P:PinFun.Core.Net.Http.WebMiddleware.Next">
            <summary>
            下一个中间件
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Http.WebMiddleware.Invoke(PinFun.Core.Net.Http.HttpContext)">
            <summary>
            执行当前中间件
            </summary>
            <param name="context">请求对象</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Net.IChannelEventHandler">
            <summary>
            
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.IChannelEventHandler.WhenDataReceived(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <summary>
            当收到数据时候被调用
            </summary>
            <param name="context">连接上下文</param>
            <param name="msg">数据</param>
        </member>
        <member name="M:PinFun.Core.Net.IChannelEventHandler.WhenConnectionConnected(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            当客户端连接成功时触发
            </summary>
            <param name="context">连接上下文</param>
        </member>
        <member name="M:PinFun.Core.Net.IChannelEventHandler.WhenConnectionClosed(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            当连接被关闭时候发生
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:PinFun.Core.Net.IChannelEventHandler.WhenExceptionCaught(DotNetty.Transport.Channels.IChannel,System.Exception)">
            <summary>
            当连接发生异常时候发生
            </summary>
            <param name="clientChannel"></param>
            <param name="exception"></param>
        </member>
        <member name="M:PinFun.Core.Net.IChannelEventHandler.WhenIdle(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Handlers.Timeout.IdleStateEvent)">
            <summary>
            当连接进入空闲状态时候发生
            </summary>
            <param name="context"></param>
            <param name="idleStateEvent"></param>
        </member>
        <member name="T:PinFun.Core.Net.Tcp.BaseTcpClient">
            <summary>
            和<see cref="T:PinFun.Core.Net.Tcp.BaseTcpServer"/>配套的客户端
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.#ctor(System.String,System.Int32)">
            <summary>
            新建一个到服务器的连接
            </summary>
            <param name="serverInfo">服务器IP或者域名</param>
            <param name="port">端口</param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.SetName(System.String)">
            <summary>
            设置当前客户端的名称
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.WriteData(System.Object)">
            <summary>
            向当前服务器写入数据
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.Config(DotNetty.Transport.Channels.MultithreadEventLoopGroup,DotNetty.Transport.Bootstrapping.Bootstrap)">
            <summary>
            配置_bootstrap，_eventLoop
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.BuildChannel(DotNetty.Transport.Channels.IChannelPipeline)">
            <summary>
            构造当前通信通道
            </summary>
            <param name="channelPipeline"></param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.EnableNettyLog">
            <summary>
            是否启用Netty的日志
            </summary>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpClient.AutoHeartbeat">
            <summary>
            是否启用自动心跳保活
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.GetLogger">
            <summary>
            获取日志对象
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.OnDataReceived(System.Object)">
            <summary>
            收到服务器发送的数据
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.OnException(System.Exception)">
            <summary>
            客户端出错
            </summary>
            <param name="exception"></param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.AutoReConnect">
            <summary>
            断开后是否自动重连
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.HeartbeatData">
            <summary>
            心跳包数据，如果返回null将不发送
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.SetTcpOption(DotNetty.Transport.Bootstrapping.Bootstrap)">
            <summary>
            设置当前TCP连接的属性
            </summary>
            <param name="bootstrap"></param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.HeartbeatTime">
            <summary>
            自动保活心跳数据发送间隔，当系统监测到超过配置时长没有发送数据之后，自动发送一个心跳包，单位：秒，默认100
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.GetCertificateInfo">
            <summary>
            如果当前连接需要加密，那么应该返回合理的证书信息，默认返回null，不加密
            </summary>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpClient.Name">
            <summary>
            当前客户端的名称
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpClient.ServerAddress">
            <summary>
            对应的服务器IP
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpClient.Port">
            <summary>
            对应的服务器端口
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpClient.IsConnected">
            <summary>
            获取当前是否已经连接上服务器
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Tcp.BaseTcpClient.OnServerConnected">
            <summary>
            和服务器连接上事件
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Tcp.BaseTcpClient.OnServerDisConnected">
            <summary>
            和服务器连接中断事件
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.SetCertificateInfo(System.String)">
            <summary>
            设置连接使用的加密证书。必须在<see cref="M:PinFun.Core.Net.Tcp.BaseTcpClient.Open"/>方法之前调用
            </summary>
            <param name="certificateFile">XX.cer证书文件地址</param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.Open">
            <summary>
            打开连接
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.Close">
            <summary>
            关闭连接
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.WhenDataReceived(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.WhenConnectionConnected(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.WhenConnectionClosed(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.WhenExceptionCaught(DotNetty.Transport.Channels.IChannel,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpClient.WhenIdle(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Handlers.Timeout.IdleStateEvent)">
            <inheritdoc />
        </member>
        <member name="T:PinFun.Core.Net.Tcp.BaseTcpConnection">
            <summary>
            通用的TCP基础连接信息
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpConnection.#ctor(DotNetty.Transport.Channels.IChannel,PinFun.Core.Net.Tcp.BaseTcpServer)">
            <summary>
            新建一个连接
            </summary>
            <param name="clientChannel"></param>
            <param name="server"></param>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpConnection.Session">
            <summary>
            用于存放客户数据的对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpConnection.Send(System.Object)">
            <summary>
            向客户端发送数据, 注意：该方法是在当前连接上发送原始数据，不同的服务可能支持的数据类型不一致
            </summary>
            <param name="data">原始数据</param>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpConnection.RemoteAddress">
            <summary>
            远程信息
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpConnection.ConnectionId">
            <summary>
            连接编号
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpConnection.Close">
            <summary>
            关闭连接
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Net.Tcp.BaseTcpServer">
            <summary>
            基础TCP服务器
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.#ctor(System.Int32,System.String)">
            <summary>
            新建一个TCP服务器
            </summary>
            <param name="port">服务端口</param>
            <param name="name">服务器名称</param>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpServer.EnableDotNettyLog">
            <summary>
            是否启用DotNetty的日志
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpServer.EnableHeartbeatCheck">
            <summary>
            是否启用心跳监测
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.BuildClientChannel(DotNetty.Transport.Channels.IChannelPipeline)">
            <summary>
            完善Client的IChannel设置，服务器会在最后添加一个通用的Handler
            </summary>
            <param name="clientChannelPipeline"></param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.DataReceived(PinFun.Core.Net.Common.IConnection,System.Object)">
            <summary>
            收到来自客户端的数据, 注意，该请求在接收数据的线程上，后续实现最好将数据读取之后另开线程进行处理
            </summary>
            <param name="connection">接收到的数据来源</param>
            <param name="data">数据对象</param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.OnException(PinFun.Core.Net.Common.IConnection,System.Exception)">
            <summary>
            当连接上发生异常时触发
            </summary>
            <param name="connection">连接对象</param>
            <param name="ex">异常信息</param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.NewConnection(PinFun.Core.Net.Common.IConnection)">
            <summary>
            当服务器接受到新的客户端连接时被触发，如果子类返回false，那么父类将不记录连接信息
            </summary>
            <param name="connection"></param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.GetLogger">
            <summary>
            获取日志对象
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.SetTcpOption(DotNetty.Transport.Bootstrapping.ServerBootstrap)">
            <summary>
            设置和TCP连接相关的属性, 基类默认设置了SoBacklog=1024, TcpNodelay=true
            </summary>
            <param name="bootstrap">ServerBootstrap</param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.SetChildTcpOption(DotNetty.Transport.Bootstrapping.ServerBootstrap)">
            <summary>
            设置bootstrap的ChildOptions, 该方法会在调用ChildHandler之后被调用
            </summary>
            <param name="bootstrap"></param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.Started">
            <summary>
            当服务器启动完成之后会被触发
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.Stopped">
            <summary>
            当服务器停止工作之后会被触发
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.RemoveConnection(PinFun.Core.Net.Common.IConnection)">
            <summary>
            移除指定的连接
            </summary>
            <param name="connection">连接对象</param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.ReadTimeout">
            <summary>
            从客户端读取数据超时时长，超过该时长未发送数据的客户端将被关闭, 仅在启用心跳功能的情况下有效，单位：秒，默认值为120
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.BuildConnection(DotNetty.Transport.Channels.IChannel)">
            <summary>
            构造一个客户端连接对象
            </summary>
            <param name="clientChannel"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.GetConnection(DotNetty.Transport.Channels.IChannel)">
            <summary>
            从连接集合中找到指定的连接
            </summary>
            <param name="clientChannel"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.IsCertificateCorrect">
            <summary>
            确认当前服务器是否具有正确的加密证书，注意：该方法仅能在<see cref="M:PinFun.Core.Net.Tcp.BaseTcpServer.Start"/>之后进行调用，在此之前调用可能无法获取到正确的数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.Start">
            <summary>
            启动服务
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.Stop">
            <summary>
            停止服务
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpServer.Port">
            <summary>
            获取当前服务器的工作端口
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpServer.Name">
            <summary>
            获取当前服务器的名称
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.SetCertificateInfo(PinFun.Core.Net.Common.TlsCertificateInfo)">
            <summary>
            设置服务器连接加密证书信息, 如果设置为null则不加密
            </summary>
            <param name="tlsCertificateInfo"></param>
        </member>
        <member name="E:PinFun.Core.Net.Tcp.BaseTcpServer.OnStarted">
            <summary>
            服务器启动完成之后触发的事件
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Tcp.BaseTcpServer.OnStopped">
            <summary>
            当服务器被停止之后会被触发
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Tcp.BaseTcpServer.OnNewConnection">
            <summary>
            有新的客户端连接的时候触发
            </summary>
        </member>
        <member name="E:PinFun.Core.Net.Tcp.BaseTcpServer.OnDisConnected">
            <summary>
            连接中断事件
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.Tcp.BaseTcpServer.AllConnections">
            <summary>
            获取当前服务器上的所有连接信息
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.BoardCase(System.Byte[])">
            <summary>
            向所有的客户端广播数据
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.WhenDataReceived(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.WhenConnectionConnected(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.WhenConnectionClosed(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.WhenExceptionCaught(DotNetty.Transport.Channels.IChannel,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.Tcp.BaseTcpServer.WhenIdle(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Handlers.Timeout.IdleStateEvent)">
            <inheritdoc />
        </member>
        <member name="T:PinFun.Core.Net.Tcp.CommonChannelHandler">
            <summary>
            通用数据处理对象
            </summary>
        </member>
        <member name="T:PinFun.Core.Net.WebSocket.WebSocketConnection">
            <summary>
            WEB Socket连接
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketConnection.#ctor(DotNetty.Transport.Channels.IChannel,PinFun.Core.Net.WebSocket.WebSocketServer)">
            <summary>
            新建一个连接对象
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.WebSocket.WebSocketConnection.Session">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketConnection.Send(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:PinFun.Core.Net.WebSocket.WebSocketConnection.RemoteAddress">
            <inheritdoc />
        </member>
        <member name="P:PinFun.Core.Net.WebSocket.WebSocketConnection.ConnectionId">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketConnection.Close">
            <inheritdoc />
        </member>
        <member name="T:PinFun.Core.Net.WebSocket.WebSocketServer">
            <summary>
            WEB Socket服务器
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketServer.#ctor(System.Int32,System.String,System.String)">
            <summary>
            新建一个WEB Socket服务器
            </summary>
            <param name="port"></param>
            <param name="name"></param>
            <param name="path"></param>
        </member>
        <member name="E:PinFun.Core.Net.WebSocket.WebSocketServer.OnDataReceived">
            <summary>
            服务器收到了客户端传输的数据事件
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.WebSocket.WebSocketServer.EnableDotNettyLog">
            <summary>
            是否启用Netty的日志
            </summary>
        </member>
        <member name="P:PinFun.Core.Net.WebSocket.WebSocketServer.EnableHeartbeatCheck">
            <summary>
            自动心跳连接
            </summary>
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketServer.SetTcpOption(DotNetty.Transport.Bootstrapping.ServerBootstrap)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketServer.BuildClientChannel(DotNetty.Transport.Channels.IChannelPipeline)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketServer.DataReceived(PinFun.Core.Net.Common.IConnection,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketServer.OnException(PinFun.Core.Net.Common.IConnection,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketServer.NewConnection(PinFun.Core.Net.Common.IConnection)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketServer.GetLogger">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketServer.BuildConnection(DotNetty.Transport.Channels.IChannel)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Net.WebSocket.WebSocketServer.WhenDataReceived(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:PinFun.Core.Net.WebSocket.WebSocketServerDataReceived">
            <summary>
            收到来自websocket客户端发送的数据
            </summary>
            <param name="server">服务器对象</param>
            <param name="client">客户端连接对象</param>
            <param name="data">数据</param>
        </member>
        <member name="T:PinFun.Core.PerformanceCounter.PerformanceCounterItem">
            <summary>
            技能计数器条目
            </summary>
        </member>
        <member name="P:PinFun.Core.PerformanceCounter.PerformanceCounterItem.Name">
            <summary>
            当前条目名称
            </summary>
        </member>
        <member name="P:PinFun.Core.PerformanceCounter.PerformanceCounterItem.Count">
            <summary>
            当前条目的数据
            </summary>
        </member>
        <member name="M:PinFun.Core.PerformanceCounter.PerformanceCounterItem.Increment">
            <summary>
            计数器数量+1
            </summary>
        </member>
        <member name="M:PinFun.Core.PerformanceCounter.PerformanceCounterItem.Decrement">
            <summary>
            计数器数量-1
            </summary>
        </member>
        <member name="T:PinFun.Core.PerformanceCounter.PerformanceCounterItemManager">
            <summary>
            内置的性能计数器，用于统计当前时刻的系统调用情况
            </summary>
        </member>
        <member name="P:PinFun.Core.PerformanceCounter.PerformanceCounterItemManager.Item(System.String)">
            <summary>
            获取一个性能计数对象, 如果没有找到，那么新建一个
            </summary>
            <param name="name">计数器名称</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.PerformanceCounter.PerformanceCounterItemManager.AllCounters">
            <summary>
            获取所有的性能计数器对象
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Properties.Resources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:PinFun.Core.Properties.Resources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:PinFun.Core.Properties.Resources.Culture">
            <summary>
              重写当前线程的 CurrentUICulture 属性
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:PinFun.Core.Properties.Resources.log4net">
            <summary>
              查找类似 &lt;log4net&gt;
             &lt;root&gt;
               &lt;level value=&quot;debug&quot; /&gt;
               &lt;appender-ref ref=&quot;RollingFileLog&quot; /&gt;
               &lt;appender-ref ref=&quot;UdpServerLog&quot; /&gt;
               &lt;!--&lt;appender-ref ref=&quot;##ConsoleLog##&quot; /&gt;--&gt;
             &lt;/root&gt;
             &lt;appender name=&quot;RollingFileLog&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt;
               &lt;appendToFile value=&quot;true&quot; /&gt;
               &lt;rollingStyle value=&quot;Date&quot; /&gt;
               &lt;datePattern value=&quot;yyyyMMdd-HH:mm:ss&quot; /&gt;
               &lt;!--日志所在目录--&gt;
               &lt;param name=&quot;File&quot; value=&quot;##$^^$##.logs/&quot; /&gt;
               &lt;param name=&quot;MaxSizeRollBackups&quot; value=&quot;-1&quot; /&gt;
            [字符串的其余部分被截断]&quot;; 的本地化字符串。
            </summary>
        </member>
        <member name="P:PinFun.Core.Properties.Resources.mimeTypes">
            <summary>
              查找 System.Byte[] 类型的本地化资源。
            </summary>
        </member>
        <member name="P:PinFun.Core.Properties.Resources.PinFun_Core_License">
            <summary>
              查找 System.Byte[] 类型的本地化资源。
            </summary>
        </member>
        <member name="P:PinFun.Core.Properties.Resources.settings">
            <summary>
              查找 System.Byte[] 类型的本地化资源。
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.DataReceiveContext">
            <summary>
            Netty接收到数据用于夸线程处理的上下文对象
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.IServiceHost">
            <summary>
            所有服务均需要实现的接口
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.IServiceHost.Name">
            <summary>
            服务名
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.IServiceHost.Start">
            <summary>
            启动服务
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.IServiceHost.Stop">
            <summary>
            停止服务
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonArgumentHelp">
            <summary>
            JSON字符串转换为CLI的参数实体
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonArgumentHelp.Convert(PinFun.Core.Api.ArgumentDefinition[],System.String,System.Func{System.String,System.Type,System.Object})">
            <summary>
            从JSON中读取指定类型入参的对象
            </summary>
            <param name="parameterInfos">入参定义</param>
            <param name="jsonString">原始json字符串</param>
            <param name="extArgumentReader">扩展的参数读取函数，参数为 参数名称，目标参数类型，返回当前参数的对象 </param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.InnerJsonTcpApiHost.EnableHeartbeatCheck">
            <summary>
            启用心跳
            </summary>
        </member>
        <member name="E:PinFun.Core.ServiceHost.JsonTcpApi.InnerJsonTcpApiHost.Invoke">
            <summary>
            调用事件
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.InvokeDecoder">
            <summary>
            基于MessagePack的解码器
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.InvokeDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <summary>
            解码
            </summary>
            <param name="context"></param>
            <param name="message"></param>
            <param name="output"></param>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.InvokeEncoder">
            <summary>
            基于MessagePack的编码器
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost">
            <summary>
            JSON TCP API 服务, 第一次初始化的对象会被记录到其Instance属性上
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost.#ctor">
            <summary>
            新建一个新的JSON TCP API 服务器
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost.Dispose">
            <summary>
            关闭服务，释放资源
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost.Name">
            <summary>
            服务名称
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost.WithName(System.String)">
            <summary>
            设置当前服务的名称
            </summary>
            <param name="name">服务名称，可以通过<see cref="T:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostManager"/>的Find方法寻找到当前对象</param>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost.Start">
            <summary>
            启动
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost.Stop">
            <summary>
            停止
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost.PushData(System.Object,System.Func{PinFun.Core.Net.Common.IConnection,System.Boolean})">
            <summary>
            向所有客户端推送数据
            </summary>
            <param name="data">待推送的数据</param>
            <param name="filterFunc">客户端筛选器, 返回true表示要发送，否则为不发送</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost.PushData(System.Object,PinFun.Core.Net.Common.IConnection)">
            <summary>
            通过本服务器向指定的客户端连接推送数据
            </summary>
            <param name="data">待推送的数据</param>
            <param name="connection">客户端连接</param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost.SourceTcpServer">
            <summary>
            原始的TCP服务器
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostConfig">
            <summary>
            基于TCP的API服务配置
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostConfig.#ctor">
            <summary>
            新建一个默认配置, 默认端口为：6001
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostConfig.Port">
            <summary>
            服务端口
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostConfig.ConnectionLog">
            <summary>
            连接日志
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostConfig.NettyLog">
            <summary>
            是否启用DotNetty的日志
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostConfig.Certificate">
            <summary>
            加密证书文件
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostConfig.GetConfigTemplate">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostManager">
            <summary>
            <see cref="T:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost"/>对象管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostManager.Regist(PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost)">
            <summary>
            登记服务
            </summary>
            <param name="host">待注册的服务器对象</param>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostManager.UnRegist(PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHost)">
            <summary>
            取消注册
            </summary>
            <param name="host"></param>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.JsonTcpApiHostManager.Find(System.String)">
            <summary>
            找到具有指定名称的JsonTcpApi服务器
            </summary>
            <param name="name">服务名称</param>
            <returns>可能为NULL</returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPackage">
            <summary>
            TCP API 请求包
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPackage.T">
            <summary>
            包类型
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPackage.D">
            <summary>
            Json字符串的数据
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPackageType">
            <summary>
            传递的包类型
            </summary>
        </member>
        <member name="F:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPackageType.Heartbeat">
            <summary>
            心跳包, 数据类型为空
            </summary>
        </member>
        <member name="F:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPackageType.Push">
            <summary>
            数据推送，数据类型为<see cref="T:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPush"/>
            </summary>
        </member>
        <member name="F:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPackageType.Request">
            <summary>
            api请求包，数据类型为<see cref="T:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiRequest"/>
            </summary>
        </member>
        <member name="F:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPackageType.Response">
            <summary>
            api反馈包，数据类型为<see cref="T:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiResponse"/>
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPush">
            <summary>
            基于TCP API的推送包
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPush.T">
            <summary>
            当前推送的数据类型
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPush.D">
            <summary>
            具体推送的消息
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiPush.ToString">
            <summary>
            Json字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiRequest">
            <summary>
            基于TCP API的请求
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiRequest.I">
            <summary>
            请求编号
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiRequest.H">
            <summary>
            请求头信息
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiRequest.C">
            <summary>
            当前请求的API名称
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiRequest.M">
            <summary>
            当前请求的方法名称
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiRequest.A">
            <summary>
            当前方法传递的参数,Json字符串
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiRequest.ToString">
            <summary>
            JSON字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiResponse">
            <summary>
            tcp api 返回值
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiResponse.I">
            <summary>
            请求编号
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiResponse.R">
            <summary>
            返回值
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.JsonTcpApi.Protocols.TcpApiResponse.ToString">
            <summary>
            JSON字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.JsonTcpApi.TcpApiInvokeContextRequest">
            <summary>
            基于JSON TCP API的调用上下文
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.JsonTcpApi.TcpApiInvokeContextRequest.Header">
            <summary>
            
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.ServiceHostManager">
            <summary>
            所有配置在config.json文件中的Services数组中的<see cref="T:PinFun.Core.ServiceHost.IServiceHost"/>的实现类管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.ServiceHostManager.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.ServiceHostManager.InvInit">
            <summary>
            反初始化
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.IParametricParser">
            <summary>
            WEB API 请求参数解析器
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.IParametricParser.ParserName">
            <summary>
            参数解析器的名称
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.IParametricParser.Parser(PinFun.Core.Api.ArgumentDefinition[],PinFun.Core.Net.Http.HttpContext,System.Text.StringBuilder)">
            <summary>
            将当前请求转化为具体的参数
            </summary>
            <param name="parameterInfos">当前需要的参数清单</param>
            <param name="context">请求上下文</param>
            <param name="logBody">当前请求的原始Body内容</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.Middleware.CorsMiddleware">
            <summary>
            允许跨域请求的中间件
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.Middleware.CorsMiddleware.#ctor(PinFun.Core.Net.Http.WebMiddleware)">
            <summary>
            新建一个允许跨域的中间件
            </summary>
            <param name="next"></param>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.Middleware.CorsMiddleware.Invoke(PinFun.Core.Net.Http.HttpContext)">
            <summary>
            处理请求
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.Middleware.IWebMiddleware">
            <summary>
            用户自定义的web中间件
            <para>注意: 所有的IWebMiddleware会以单实例方式运行</para>
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.Middleware.IWebMiddleware.Name">
            <summary>
            中间件名称，记录日志使用
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.Middleware.IWebMiddleware.CanProcess(System.String)">
            <summary>
            是否可以处理当前请求
            </summary>
            <param name="uri">请求地址</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.Middleware.IWebMiddleware.Process(PinFun.Core.Net.Http.HttpContext)">
            <summary>
            处理请求
            </summary>
            <param name="context">http上下文对象</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.Middleware.StaticFileMiddleware">
            <summary>
            默认的静态文件服务器
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.Middleware.StaticFileMiddleware.#ctor(PinFun.Core.Net.Http.WebMiddleware)">
            <summary>
            新建一个静态文件服务器
            </summary>
            <param name="next"></param>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.Middleware.StaticFileMiddleware.Invoke(PinFun.Core.Net.Http.HttpContext)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.Middleware.WebApiMiddleware">
            <summary>
            WEB API 中间件
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.Middleware.WebApiMiddleware.#ctor(PinFun.Core.Net.Http.WebMiddleware)">
            <summary>
            新建一个 WEB API 中间件
            </summary>
            <param name="next"></param>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.Middleware.WebApiMiddleware.Invoke(PinFun.Core.Net.Http.HttpContext)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.Middleware.WebMiddlewareManager">
            <summary>
            IWebMiddleware 管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.Middleware.WebMiddlewareManager.#ctor(PinFun.Core.Net.Http.WebMiddleware)">
            <summary>
            
            </summary>
            <param name="next"></param>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.Middleware.WebMiddlewareManager.Invoke(PinFun.Core.Net.Http.HttpContext)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.ParametricParserManager">
            <summary>
            WEB API 参数解析器
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.ParametricParserManager.GetParametricParser(PinFun.Core.Net.Http.HttpContext)">
            <summary>
            为当前请求找到合适的参数解析器
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.ParametricParser.HttpContextHelper.HeadersToString(DotNetty.Codecs.Http.HttpHeaders)">
            <summary>
            将请求头转换为字符串
            </summary>
            <param name="headerDictionary"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.ParametricParser.HttpParametricParser">
            <summary>
            默认的HTTP参数解析器，该解析器解析的类型是application/json
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.ParametricParser.StringArrayParametricParser">
            <summary>
            字符串数组字符串解析器
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.ParametricParser.StringArrayParametricParser.ParserName">
            <summary>
            
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.ParametricParser.StringArrayParametricParser.Parser(PinFun.Core.Api.ArgumentDefinition[],PinFun.Core.Net.Http.HttpContext,System.Text.StringBuilder)">
            <summary>
            
            </summary>
            <param name="parameterInfos"></param>
            <param name="context"></param>
            <param name="sourceBody"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.WebApiHost">
            <summary>
            默认的WEB API服务器
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.WebApiHost.#ctor">
            <summary>
            新建一个WEB API服务器
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.WebApiHost.Dispose">
            <summary>
            关闭服务，释放资源
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WebApiHost.Name">
            <summary>
            当前服务器的名称
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.WebApiHost.Start">
            <summary>
            启动服务
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.WebApiHost.Stop">
            <summary>
            关闭服务
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig">
            <summary>
            WEB API 服务器配置
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig.#ctor">
            <summary>
            新建一个默认配置，端口为：6002
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig.Port">
            <summary>
            工作端口
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig.ApiUrl">
            <summary>
            API请求根地址
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig.NettyLog">
            <summary>
            是否启用DotNetty的日志
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig.AllowCors">
            <summary>
            是否允许跨域请求
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig.LogAllRequest">
            <summary>
            是否记录所有请求信息
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig.MaxContentLength">
            <summary>
            单次请求所允许的最大值，单位 kb
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig.StaticFileConfig">
            <summary>
            文件服务的配置
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig.Certificate">
            <summary>
            加密证书文件
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebApi.WebApiHostConfig.GetConfigTemplate">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.WwwServerConfig">
            <summary>
            提供文件服务的配置
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WwwServerConfig.Uri">
            <summary>
            请求根地址
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WwwServerConfig.BaseDir">
            <summary>
            主路径
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebApi.WwwServerConfig.MineMap">
            <summary>
            Content-Type 映射关系
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebApi.WebApiInvokeContextRequest">
            <summary>
            基于WEB API的调用上下文
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebPush.WsClientLoginResult">
            <summary>
            web socket 客户端登录结果
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WsClientLoginResult.#ctor">
            <summary>
            新建一个ws登录结果
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebPush.WsClientLoginResult.Successed">
            <summary>
            获取或者设置登录结果
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebPush.WsClientLoginResult.Message">
            <summary>
            获取或者设置登录失败的消息
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebPush.IWebEvent">
            <summary>
            可用于WEB推送的事件对象, 可以通过 http://xxx.xxx.xxx.xxx:xx/webevents查询到所有定义
            <para>注意: </para>
            <para>1. 如果系统未使用PinFun.Server.Web组件，那么上述地址不可用</para>
            <para>2. 如果未启用WebApiHost，那么上述地址不可用</para>
            <para>3. 如果客户端需要手工订阅WEB事件，那么事件名称为对应类的FullName</para>
            </summary>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebPush.IWebSocketClientLoginHandler">
            <summary>
            websocket客户端登录处理程序
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.IWebSocketClientLoginHandler.Login(PinFun.Core.Net.Common.IConnection,System.String)">
            <summary>
            客户端登录
            </summary>
            <param name="connection">当前客户端的连接对象</param>
            <param name="clientInfo">登录凭据</param>
            <returns>登录结果</returns>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebPush.WebEvent">
            <summary>
            WEB事件，该方法会通过<see cref="T:PinFun.Core.ServiceHost.WebPush.WebPushHost"/>向客户端推送强类型的对象
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WebEvent.Raise(PinFun.Core.ServiceHost.WebPush.IWebEvent)">
            <summary>
            触发事件, 必须要客户端订阅了的事件才会被发送
            </summary>
            <param name="event">事件对象</param>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WebEvent.Raise(PinFun.Core.ServiceHost.WebPush.IWebEvent,System.Func{PinFun.Core.Net.Common.IConnection,System.Boolean})">
            <summary>
            触发事件, 必须要客户端订阅了的事件才会被发送
            </summary>
            <param name="event">事件对象</param>
            <param name="clientFilter">客户筛选器</param>
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebPush.WebPushHost">
            <summary>
            基于WEB Socket Server的web推送服务器
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WebPushHost.#ctor">
            <summary>
            新建一个web推送服务
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WebPushHost.Dispose">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WebPushHost.PushData(System.String,PinFun.Core.Net.Common.IConnection)">
            <summary>
            向指定的客户端推送数据
            </summary>
            <param name="data"></param>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WebPushHost.PushData(System.String,System.Func{PinFun.Core.Net.Common.IConnection,System.Boolean})">
            <summary>
            向一组客户端推送数据
            </summary>
            <param name="data">待推送的数据</param>
            <param name="filterFunc">客户端筛选方法</param>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebPush.WebPushHost.Name">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WebPushHost.Start">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WebPushHost.Stop">
            <inheritdoc />
        </member>
        <member name="T:PinFun.Core.ServiceHost.WebPush.WebPushHostConfig">
            <summary>
            WEB PUSH 配置
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WebPushHostConfig.#ctor">
            <summary>
            创建一个默认配置，端口默认为：6003
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebPush.WebPushHostConfig.Port">
            <summary>
            工作端口
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebPush.WebPushHostConfig.LogAllRequest">
            <summary>
            是否记录所有日志
            </summary>
        </member>
        <member name="P:PinFun.Core.ServiceHost.WebPush.WebPushHostConfig.Certificate">
            <summary>
            加密证书文件
            </summary>
        </member>
        <member name="M:PinFun.Core.ServiceHost.WebPush.WebPushHostConfig.GetConfigTemplate">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Startup">
            <summary>
            框架启动包裹类
            </summary>
        </member>
        <member name="E:PinFun.Core.Startup.OnCrash">
            <summary>
            崩溃事件
            </summary>
        </member>
        <member name="M:PinFun.Core.Startup.Init(System.Action)">
            <summary>
            初始化框架的配置文件，然后依次完成如下组件的初始化
            <para>初始化log4net日志组件</para>
            <para>调用afterLog4NetInited方法，如果有的话</para>
            <para>初始化<see cref="T:PinFun.Core.DependenceInversion.LiteDi"/></para>
            <para>初始化事件订阅管理器<see cref="T:PinFun.Core.EventSubscription.EventSubscriptManager"/></para>
            <para>初始化<see cref="T:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClientManager"/></para>
            <para>启动所有<see cref="T:PinFun.Core.Worker.AutoStartWorker`1"/>类</para>
            <para>启动所有<see cref="T:PinFun.Core.LiteService.ILiteService"/>的实现类</para>
            <para>启动配置文件中的Services节点的<see cref="T:PinFun.Core.ServiceHost.IServiceHost"/>的实现类</para>
            </summary>
            <param name="afterLog4NetInited">在log4net初始化完成之后被调用的方法</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Startup.InvInit">
            <summary>
            反初始化
            <para>1: 停止配置文件中的Services节点的<see cref="T:PinFun.Core.ServiceHost.IServiceHost"/>的实现类</para>
            <para>2: 停止所有<see cref="T:PinFun.Core.LiteService.ILiteService"/>的实现类</para>
            <para>3: 停止所有<see cref="T:PinFun.Core.Worker.AutoStartWorker`1"/>类</para>
            <para>4: 反初始化<see cref="T:PinFun.Core.Client.JsonTcpApi.JsonTcpApiClientManager"/>类</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Time.ITimeSetter">
            <summary>
            本地时间设置程序
            </summary>
        </member>
        <member name="M:PinFun.Core.Time.ITimeSetter.SetLocalTime(System.DateTime)">
            <summary>
            设置本地时间
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:PinFun.Core.Time.ITimeSetter.IsSupported">
            <summary>
            是否支持当前操作系统
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Time.LinuxTimeSetter">
            <summary>
            Linux系统上的时间设置提供程序
            </summary>
        </member>
        <member name="M:PinFun.Core.Time.LinuxTimeSetter.SetLocalTime(System.DateTime)">
            <summary>
            设置本地系统时间
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:PinFun.Core.Time.LinuxTimeSetter.IsSupported">
            <summary>
            是否支持当前操作系统
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Time.NtpConfig">
            <summary>
            NTP服务配置
            </summary>
        </member>
        <member name="M:PinFun.Core.Time.NtpConfig.#ctor">
            <summary>
            初始化默认配置
            </summary>
        </member>
        <member name="P:PinFun.Core.Time.NtpConfig.Servers">
            <summary>
            服务器列表
            </summary>
        </member>
        <member name="P:PinFun.Core.Time.NtpConfig.SyncInterval">
            <summary>
            同步间隔，单位秒
            </summary>
        </member>
        <member name="P:PinFun.Core.Time.NtpConfig.NtpServerInfos">
            <summary>
            解析之后的服务器信息
            </summary>
        </member>
        <member name="P:PinFun.Core.Time.NtpConfig.SyncLocalMachine">
            <summary>
            是否同步本地机器时间
            </summary>
        </member>
        <member name="M:PinFun.Core.Time.NtpConfig.GetConfigTemplate">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Time.NtpConfig.Current">
            <summary>
            获取当前默认配置
            </summary>
        </member>
        <member name="T:PinFun.Core.Time.NtpTimeService">
            <summary>
            NTP时间同步服务
            </summary>
        </member>
        <member name="M:PinFun.Core.Time.NtpTimeService.#ctor">
            <summary>
            初始化NTP时间同步服务
            </summary>
        </member>
        <member name="M:PinFun.Core.Time.NtpTimeService.OnScheduledTask">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Time.NtpTimeService.Now">
            <summary>
            获取当前时间
            </summary>
        </member>
        <member name="T:PinFun.Core.Time.WindowsTimeSetter">
            <summary>
            Windows平台设置本机时间
            </summary>
        </member>
        <member name="M:PinFun.Core.Time.WindowsTimeSetter.SetLocalTime(System.DateTime)">
            <summary>
            设置本地操作系统时间
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:PinFun.Core.Time.WindowsTimeSetter.IsSupported">
            <summary>
            是否支持当前操作系统
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Utils.AppAssemblyManager">
            <summary>
            当前程序域中的所有DLL管理器, 其会加载当前目录下的所有dll和exe文件
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.AppAssemblyManager.Init(System.String)">
            <summary>
            采用指定的目录初始化
            </summary>
            <param name="dir"></param>
        </member>
        <member name="P:PinFun.Core.Utils.AppAssemblyManager.Instance">
            <summary>
            获取当前类的实例
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.AppAssemblyManager.#ctor(System.Runtime.Loader.AssemblyLoadContext,System.String)">
            <summary>
            当前程序域中的所有DLL管理器, 其会加载当前目录下的所有dll和exe文件
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.AppAssemblyManager.Load(System.String)">
            <summary>
            通过当前程序集管理器上下文加载某个文件，该文件的加载不会被缓存到当前管理器中
            </summary>
            <param name="file">文件地址</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.AppAssemblyManager.FindAllInterfaceImpl``1(System.Boolean)">
            <summary>
            找到所有实现了某个接口的公共类，抽象类不会被返回
            </summary>
            <typeparam name="TInterface"></typeparam>
            <param name="includePrivate">是否包含私有类</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.AppAssemblyManager.FindAllInterfaceImpl(System.Type,System.Boolean)">
            <summary>
            找到指定接口的所有实现类
            </summary>
            <param name="interfaceType"></param>
            <param name="includePrivate">是否包含私有类</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.AppAssemblyManager.GetAllAssemblies">
            <summary>
            获取当前程序域中加载的所有程序集
            </summary>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Utils.BaseBusiness">
            <summary>
            所有业务类的基类，凡是继承至该基类的对象可自动实例化内部采用<see cref="T:PinFun.Core.Api.Attributes.RemoteApiAttribute"/>和<see cref="T:PinFun.Core.DependenceInversion.LiteDiInitializationAttribute"/>标记的变量
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.BaseBusiness.#ctor">
            <summary>
            业务类基类构造函数
            </summary>
        </member>
        <member name="T:PinFun.Core.Utils.CallContext">
            <summary>
            提供基于调用的上下文
            <para>注意：通过该类保存的数据，在初次设置线程以及其设置的子线程中均可访问，子线程如果修改了数据，父线程是不会知道的</para>
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.CallContext.SetData(System.String,System.Object)">
            <summary>
            在当前上下文中设置对象, 和<see cref="M:PinFun.Core.Utils.CallContext.GetData(System.String)"/>配合使用
            </summary>
            <param name="name">对象名称</param>
            <param name="data">对象值</param>
        </member>
        <member name="M:PinFun.Core.Utils.CallContext.GetData(System.String)">
            <summary>
            在当前调用上下文中获取对象, 和<see cref="M:PinFun.Core.Utils.CallContext.SetData(System.String,System.Object)"/>配合使用
            </summary>
            <param name="name">对象名称</param>
            <returns>未找到则为NULL</returns>
        </member>
        <member name="M:PinFun.Core.Utils.CallContext.SetT``1(System.String,``0)">
            <summary>
            设置强类型数据，该方法只能个<see cref="M:PinFun.Core.Utils.CallContext.GetT``1(System.String)"/>配合使用
            </summary>
            <typeparam name="T">对象类型</typeparam>
            <param name="name">名称</param>
            <param name="data">数据</param>
        </member>
        <member name="M:PinFun.Core.Utils.CallContext.GetT``1(System.String)">
            <summary>
            获取强类型数据，该方法只能个<see cref="M:PinFun.Core.Utils.CallContext.SetT``1(System.String,``0)"/>配合使用
            </summary>
            <typeparam name="T">对象类型</typeparam>
            <param name="name">名称</param>
            <returns>返回当初设置的数据</returns>
        </member>
        <member name="T:PinFun.Core.Utils.CallContext`1">
            <summary>
            基于泛型的调用上下文
            <para>注意：通过该类保存的数据，在初次设置线程以及其设置的子线程中均可访问，子线程如果修改了数据，父线程是不会知道的</para>
            </summary>
            <typeparam name="T">泛型类型</typeparam>
        </member>
        <member name="M:PinFun.Core.Utils.CallContext`1.SetData(System.String,`0)">
            <summary>
            设置数据
            </summary>
            <param name="name">名称</param>
            <param name="data">数据</param>
        </member>
        <member name="M:PinFun.Core.Utils.CallContext`1.GetData(System.String)">
            <summary>
            获取数据
            </summary>
            <param name="name">名称</param>
            <returns>没找到的话返回default(T)</returns>
        </member>
        <member name="T:PinFun.Core.Utils.CommandArguments">
            <summary>
            基于控制台的命令参数解析器, 参数传递方式为 key=value key=value
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.CommandArguments.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="P:PinFun.Core.Utils.CommandArguments.ExecutableFile">
            <summary>
            获取当前主程序可执行文件的完整路径
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.CommandArguments.Get``1(System.String)">
            <summary>
            获取指定类型的值，如果没有的话返回默认值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.CommandArguments.Get(System.String,System.String)">
            <summary>
            获取某个名称的值，如果没有找到的话提示用户输入
            </summary>
            <param name="key"></param>
            <param name="inputTip"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.CommandArguments.HasSet(System.String)">
            <summary>
            确认命令行是否传递了指定的参数
            </summary>
            <param name="key">参数名称</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.CommandArguments.UseHelp(System.Action)">
            <summary>
            输出帮助信息, /? 显示帮助信息
            </summary>
            <param name="outputHelpAction">帮助方法</param>
        </member>
        <member name="T:PinFun.Core.Utils.ConfigFileChanged">
            <summary>
            配置文件发生变化
            </summary>
        </member>
        <member name="T:PinFun.Core.Utils.ConfigFileWatcher">
            <summary>
            配置文件变更监测, 需要调用Start方法
            </summary>
        </member>
        <member name="E:PinFun.Core.Utils.ConfigFileWatcher.OnConfigFileChanged">
            <summary>
            配置文件发生变更事件
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.ConfigFileWatcher.#ctor(System.String)">
            <summary>
            新建一个监视器
            </summary>
            <param name="file">待监视的文件</param>
        </member>
        <member name="M:PinFun.Core.Utils.ConfigFileWatcher.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="T:PinFun.Core.Utils.FirstNewSingleton`1">
            <summary>
            采用第一次实例化的类作为唯一实例
            </summary>
            <typeparam name="T">实例类型</typeparam>
        </member>
        <member name="M:PinFun.Core.Utils.FirstNewSingleton`1.#ctor">
            <summary>
            新建一个采用第一次实例化的类作为唯一实例
            </summary>
        </member>
        <member name="P:PinFun.Core.Utils.FirstNewSingleton`1.FirstInstance">
            <summary>
            获取当前类第一次实例化的对象
            </summary>
        </member>
        <member name="T:PinFun.Core.Utils.HostConfig">
            <summary>
            全局配置，配置文件为当前启动程序的名称+.json文件
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.HostConfig.#ctor">
            <summary>
            新建一个HostConfig配置文件对象
            </summary>
        </member>
        <member name="P:PinFun.Core.Utils.HostConfig.Services">
            <summary>
            获取当前配置文件中配置的所有服务类型，注意，服务类型必须实现接口<see cref="T:PinFun.Core.ServiceHost.IServiceHost"/>
            </summary>
        </member>
        <member name="P:PinFun.Core.Utils.HostConfig.LogAllApiRequest">
            <summary>
            是否在日志中记录所有的API请求
            </summary>
        </member>
        <member name="P:PinFun.Core.Utils.HostConfig.Log4NetConfigFile">
            <summary>
            log4net日志框架的配置文件，如果未指定的话将采用内部默认的配置文件
            </summary>
        </member>
        <member name="P:PinFun.Core.Utils.HostConfig.MachineCode">
            <summary>
            获取或者设置当前计算机的机器码，必须是16位，且每一位不能大于f，也就是说它本身是一个16进制数
            </summary>
        </member>
        <member name="P:PinFun.Core.Utils.HostConfig.NtpServer">
            <summary>
            Ntp服务器地址
            </summary>
        </member>
        <member name="P:PinFun.Core.Utils.HostConfig.ApiManagerType">
            <summary>
            获取当前程序中的API管理器对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.HostConfig.GetConfig``1(System.String)">
            <summary>
            从当前配置文件中读取指定的配置对象
            </summary>
            <typeparam name="T">目标配置对象</typeparam>
            <param name="name">节点名称</param>
            <returns>未找到则为NULL</returns>
        </member>
        <member name="M:PinFun.Core.Utils.HostConfig.GetConfig``1">
            <summary>
            以配置对象的类名称作为依据从配置文件中进行读取
            </summary>
            <typeparam name="T">目标配置对象</typeparam>
            <returns>未找到则为NULL</returns>
        </member>
        <member name="T:PinFun.Core.Utils.JsonHelper.Extentions">
            <summary>
            扩展方法
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.JsonHelper.Extentions.UseJavaDateTime(Newtonsoft.Json.Serialization.JsonProperty)">
            <summary>
            尝试添加采用JavaTimestamp格式的时间转换器
            </summary>
            <param name="jsonProperty"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.JsonHelper.Extentions.UsePinFunContractResolver(Newtonsoft.Json.JsonSerializerSettings,System.Action{PinFun.Core.Utils.JsonHelper.PinFunContractResolver})">
            <summary>
            设置序列化设置使用的协议转换器为PinFunContractResolver
            </summary>
            <param name="serializerSettings">序列化设置</param>
            <param name="converters">自定义转换器</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Utils.JsonHelper.JavaDateTimeConverter">
            <summary>
            提供JavaTimestamp类型的时间日期转换能力
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.JsonHelper.JavaDateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Utils.JsonHelper.JavaDateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Utils.JsonHelper.JavaDateTimeConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:PinFun.Core.Utils.JsonHelper.PinFunContractResolver">
            <summary>
            本框架自定义的协议解析器
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.JsonHelper.PinFunContractResolver.CreateProperties(System.Type,Newtonsoft.Json.MemberSerialization)">
            <inheritdoc />
        </member>
        <member name="M:PinFun.Core.Utils.JsonHelper.PinFunContractResolver.WithConverter(System.Func{Newtonsoft.Json.Serialization.JsonProperty,Newtonsoft.Json.JsonConverter})">
            <summary>
            增加自定义的Converter
            </summary>
            <param name="setter">Converter设置器</param>
            <returns>当前对象</returns>
        </member>
        <member name="T:PinFun.Core.Utils.LastNewSingleton`1">
            <summary>
            采用最后一次实例化的对象作为当前类的唯一实例
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:PinFun.Core.Utils.LastNewSingleton`1.#ctor">
            <summary>
            采用最后一次实例化的对象作为当前类的唯一实例
            </summary>
        </member>
        <member name="P:PinFun.Core.Utils.LastNewSingleton`1.LastInstance">
            <summary>
            获取当前类第一次实例化的对象
            </summary>
        </member>
        <member name="T:PinFun.Core.Utils.LiteDiRemoteApiInitHelper">
            <summary>
            LiteDi和RemoteApi实例化帮助程序
            </summary>
        </member>
        <member name="T:PinFun.Core.Utils.LocalSettings">
            <summary>
            本地全局设置管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.LocalSettings.#ctor">
            <summary>
            初始化本地设置
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.LocalSettings.Get``1(System.String,``0)">
            <summary>
            获取设置内容
            </summary>
            <typeparam name="T">需要返回的类型</typeparam>
            <param name="name">设置名称</param>
            <param name="default">当前设置的默认值</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.LocalSettings.Set(System.String,System.Object)">
            <summary>
            更改配置文件中的某个配置值
            </summary>
            <param name="name">设置名称</param>
            <param name="value">值</param>
        </member>
        <member name="T:PinFun.Core.Utils.Performance">
            <summary>
            性能检测器
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.Performance.#ctor(log4net.ILog,System.Int32,System.String)">
            <summary>
            初始化性能监视器
            </summary>
            <param name="log">日志对象</param>
            <param name="warningTime">最长监视时长: 单位毫秒</param>
            <param name="warningMessage">消息, 支持两个参数{0}：warningTime/1000; {1}：实际耗时, 单位为秒</param>
        </member>
        <member name="M:PinFun.Core.Utils.Performance.Dispose">
            <summary>
            释放资源，并且确定是否要记录日志
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.Performance.ElapsedTime">
            <summary>
            获取当前操作的耗时信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Performance.New(log4net.ILog,System.Int32,System.String)">
            <summary>
            获取一个新的性能检测器
            </summary>
            <param name="log"></param>
            <param name="warningTime">最长监视时长: 单位毫秒</param>
            <param name="warningMessage">消息, 支持两个参数{0}：warningTime/1000; {1}：实际耗时, 单位为秒</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Utils.DbExtend">
            <summary>
            数据库扩展方法
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.DbExtend.TryInsert``1(PinFun.Core.DataBase.Db,``0[])">
            <summary>
            尝试在数据库中插入数据，如果指定主键的数据已经存在，那么不会做插入操作
            </summary>
            <typeparam name="T">实体类型</typeparam>
            <param name="database">数据库对象</param>
            <param name="entities">实体对象清单</param>
            <returns>如果成功插入，那么返回1，否则返回0</returns>
        </member>
        <member name="M:PinFun.Core.Utils.DbExtend.Insert``1(PinFun.Core.DataBase.Db,``0)">
            <summary>
            插入数据，如果主键冲突，会报错
            </summary>
            <typeparam name="T">待插入数据类型</typeparam>
            <param name="database">数据库对象</param>
            <param name="entity">待插入数据对象</param>
            <returns>影响行数</returns>
        </member>
        <member name="M:PinFun.Core.Utils.DbExtend.GetAll``1(PinFun.Core.DataBase.Db)">
            <summary>
            查询某个表的所有数据，注意：大数据量表请勿使用
            </summary>
            <typeparam name="T">待返回数据类型</typeparam>
            <param name="database">数据库对象</param>
            <returns>结果列表</returns>
        </member>
        <member name="M:PinFun.Core.Utils.DbExtend.GetFirstOrDefault``1(PinFun.Core.DataBase.Db,System.Object)">
            <summary>
            通过主键查询数据
            </summary>
            <typeparam name="T">待返回对象类型</typeparam>
            <param name="database">数据库对象</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.DbExtend.Update``1(PinFun.Core.DataBase.Db,``0)">
            <summary>
            通过主键更新数据，注意，此操作会更新所有非主键字段（CreateXXX相关的三个字段不会被更新）
            </summary>
            <typeparam name="T">待更新类型</typeparam>
            <param name="database">数据库对象</param>
            <param name="entity">待更新对象</param>
            <returns>影响行数</returns>
        </member>
        <member name="T:PinFun.Core.Utils.ISystemPresetDataInitializer">
            <summary>
            系统预设数据初始化器，在程序每次启动的时候会调用该接口的所有实现类，以便于进行数据初始化或做他用途
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.ISystemPresetDataInitializer.Initialize(PinFun.Core.DataBase.Db)">
            <summary>
            初始化
            </summary>
            <param name="database">当前数据库的数据库访问对象</param>
        </member>
        <member name="T:PinFun.Core.Utils.SystemPresetDataInitializerManager">
            <summary>
            系统预设数据初始化器管理工具
            </summary>
        </member>
        <member name="T:PinFun.Core.Utils.SetTimeout">
            <summary>
            延时指定时长之后再执行代码，可取消，类似于javascript中的SetTimeout, 待执行的方法需要自行处理异常
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.SetTimeout.New(System.Int32,System.Action)">
            <summary>
            创建一个新的延时器
            </summary>
            <param name="delay">延时时长，单位毫秒</param>
            <param name="action">延时到期之后需要执行的代码</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.SetTimeout.#ctor(System.Int32,System.Action)">
            <summary>
            创建一个新的延时器
            </summary>
            <param name="delay">延时时长，单位毫秒</param>
            <param name="action">延时到期之后需要执行的代码</param>
        </member>
        <member name="M:PinFun.Core.Utils.SetTimeout.Start">
            <summary>
            启动延时器
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.SetTimeout.Cancel">
            <summary>
            取消延时器
            </summary>
        </member>
        <member name="T:PinFun.Core.Utils.Singleton`1">
            <summary>
            所有仅需要单实例的类，均可继承至该类
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:PinFun.Core.Utils.Singleton`1.Instance">
            <summary>
            获取当前类的唯一实例
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.Singleton`1.#ctor">
            <summary>
            所有仅需要单实例的类，均可继承至该类
            </summary>
        </member>
        <member name="T:PinFun.Core.Utils.SnowflakeId">
            <summary>
            类似于雪花算法的一个ID生成器
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.SnowflakeId.NextId(System.DateTime@)">
            <summary>
            获取下一个可用的编号, 并且同时得到该ID的生成时间用于数据CreateAt字段赋值
            </summary>
            <param name="idGenerateAt">当前ID的生成时间</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.InnerClock.GetTime(System.Int32@,System.Int32@)">
            <summary>
            获取天数和秒数
            </summary>
            <param name="day"></param>
            <param name="second"></param>
        </member>
        <member name="T:PinFun.Core.Utils.TerminalHelper">
            <summary>
            控制台帮助类
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.TerminalHelper.Run(System.String)">
            <summary>
            执行命令，并且返回结果
            </summary>
            <param name="command">命令内容</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Utils.Utils">
            <summary>
            方法调用扩展方法
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GetAllSubAttributeType``1(System.Collections.Generic.IEnumerable{System.Attribute},System.Action{System.Object})">
            <summary>
            在属性清单中获取指定基类的子类属性类型清单
            </summary>
            <typeparam name="TBaseAttribute">基类属性或接口</typeparam>
            <param name="customAttributes"></param>
            <param name="callback">在循环过程中产生的回调</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.SequenceCycle``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            正序循环某个数组
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="callback"></param>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.ReverseCycle``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            反序循环某个数组
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="callback"></param>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GetMd5(System.String)">
            <summary>
            获取某个字符串的MD5值
            </summary>
            <param name="source">原始字符串</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.OrdinalIgnoreCaseEquals(System.String,System.String)">
            <summary>
            忽略大小写的字符串是否相等比较
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.OrdinalIgnoreCaseStartsWith(System.String,System.String)">
            <summary>
            忽略大小写的字符串是否已b串开始
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.TicksToSecond(System.Int64)">
            <summary>
            将毫微秒转化成秒
            </summary>
            <param name="ticks">毫微秒</param>
            <returns>秒</returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.IsSameWith(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            比较两个字符串数组是否一样
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GetFileVersion(System.String)">
            <summary>
            获取指定文件的ProductVersion信息
            </summary>
            <param name="file">文件地址</param>
            <returns>文件版本信息，如果文件不存在，则返回NULL</returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GetFileVersion(System.Reflection.Assembly)">
            <summary>
            获取指定程序集的ProductVersion信息
            </summary>
            <param name="assembly">程序集</param>
            <returns>文件版本信息，如果文件不存在，则返回NULL</returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GetFileVersion">
            <summary>
            获取当前正在执行的程序集的版本
            </summary>
            <returns>文件版本信息，如果文件不存在，则返回NULL</returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GetFileSeparator">
            <summary>
            获取当前操作系统的文件分隔符
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.IsIpV4Address(System.String)">
            <summary>
            判断给定的一个字符串是否是IPv4地址
            </summary>
            <param name="ipv4Address"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.ToBytes(System.Int32)">
            <summary>
            将一个32位数字转换为4字节的byte
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.IsIpV6Address(System.String)">
            <summary>
            判断给定的一个字符串是否是合法的IPv6地址
            </summary>
            <param name="ipv6Address"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.IsMatchFrom(System.Collections.Generic.IEnumerable{System.Byte},System.Int32,System.Byte[])">
            <summary>
            从index开始，之后紧接的数据是否和target的一致
            </summary>
            <param name="source">原始数据</param>
            <param name="index">起始位置，0开始</param>
            <param name="target">目标数据</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.IndexesOf(System.Byte[],System.Byte[])">
            <summary>
            在指定的byte数组中寻找所有子串pattern的位置
            </summary>
            <param name="source"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GetMethodNamespace(System.Reflection.MethodInfo)">
            <summary>
            获取某个方法的完成名称，包括：程序集文件名+名称空间+接口名称，已“.”分隔
            </summary>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.Format(System.String,System.Object[])">
            <summary>
            格式化字符串
            </summary>
            <param name="template">字符串模板</param>
            <param name="arguments">格式化内容</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.IsTaskOrTaskT(System.Type)">
            <summary>
            <![CDATA[判断给定的类型是否是Task或者Task<T>类型]]>
            </summary>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GetProcessName">
            <summary>
            获取当前运行进程的名称
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GetMemberName``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            获取某个属性表达式所表达的属性名称
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression">属性表达式</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.ToJavaTimestamp(System.DateTime)">
            <summary>
            将.Net中的日期时间转换为Java中的时间戳格式
            </summary>
            <param name="dateTime">带转换的日期时间</param>
            <returns>转换后的时间戳</returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.FromJavaTimestamp(System.Object)">
            <summary>
            将Java的时间戳转换为.Net中的时间
            </summary>
            <param name="javaTimestamp">时间戳</param>
            <returns>转换后的日期时间</returns>
        </member>
        <member name="T:PinFun.Core.Utils.Utils.RSA">
            <summary>
            RSA加解密方法
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.RSA.Encrypt(System.String,System.String@,System.String@)">
            <summary>
            自动生成公钥和密钥并且执行加密, 返回加密之后的base64字符串
            </summary>
            <param name="plainText">明文</param>
            <param name="publicKey">当前使用的公钥</param>
            <param name="privateKey">当前使用的密钥</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.RSA.Encrypt2Byte(System.String,System.String@,System.String@)">
            <summary>
            自动生成公钥和密钥并且执行加密，返回加密之后的byte数组
            </summary>
            <param name="plainText">明文</param>
            <param name="publicKey">当前使用的公钥</param>
            <param name="privateKey">当前使用的密钥</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.RSA.Decrypt(System.String,System.String)">
            <summary>
            解密
            </summary>
            <param name="cypherText">密文</param>
            <param name="privateKey">私钥</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.RSA.Decrypt2Byte(System.String,System.String)">
            <summary>
            解密返回byte数组
            </summary>
            <param name="cypherText">密文</param>
            <param name="privateKey">私钥</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.RSA.Decrypt2Byte(System.Byte[],System.String)">
            <summary>
            解密返回byte数组
            </summary>
            <param name="dataToDecrypt">待解密的数据</param>
            <param name="privateKey">私钥</param>
            <exception cref="T:System.Security.Cryptography.CryptographicException"></exception>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.RSA.Encrypt(System.String,System.String)">
            <summary>
            加密
            </summary>
            <param name="plainText">明文</param>
            <param name="publicKey">公钥</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.RSA.Encrypt2Byte(System.String,System.String)">
            <summary>
            加密, 返回byte数组
            </summary>
            <param name="plainText">明文</param>
            <param name="publicKey">公钥</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.RSA.Encrypt2Byte(System.Byte[],System.String)">
            <summary>
            加密, 返回byte数组
            </summary>
            <param name="dataToEncrypt">待加密数据</param>
            <param name="publicKey">公钥</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.RSA.Signature(System.Byte[],System.String)">
            <summary>
            数字签名
            </summary>
            <param name="data">待签名的数据</param>
            <param name="privateKey">私钥</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.RSA.VerifySignature(System.Byte[],System.Byte[],System.String)">
            <summary>
            验证签名
            </summary>
            <param name="data">待签名的数据</param>
            <param name="signature">公钥</param>
            <param name="publicKey">签名</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Utils.Utils.DES">
            <summary>
            DES加密算法
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.DES.CreateKeyIv(System.String@,System.String@)">
            <summary>
            随机生成key和iv
            </summary>
            <param name="key"></param>
            <param name="iv"></param>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.DES.Encrypt(System.Byte[],System.String,System.String)">
            <summary>
            加密
            </summary>
            <param name="data">待加密的数据</param>
            <param name="key">key</param>
            <param name="iv">iv</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.DES.Decrypt(System.Byte[],System.String,System.String)">
            <summary>
            解密
            </summary>
            <param name="encryptedBytes">被加密的数据</param>
            <param name="key">加密时key</param>
            <param name="iv">加密时iv</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Utils.Utils.GZip">
            <summary>
            采用Gzip算法进行压缩和解压
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GZip.Zip(System.Byte[])">
            <summary>
            压缩
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.GZip.UnZip(System.Byte[])">
            <summary>
            解压
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Utils.Utils.BinarySerialize">
            <summary>
            调用系统自带的二进制序列化方法，相关对象必须是打了<see cref="T:System.SerializableAttribute"/>标记
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.BinarySerialize.Serialize(System.Object)">
            <summary>
            序列化
            </summary>
            <param name="data">待序列化的对象，不能为null</param>
            <returns>序列化之后的数据</returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.BinarySerialize.DeSerialize``1(System.Byte[])">
            <summary>
            反序列化
            </summary>
            <typeparam name="T">待返回的对象类型</typeparam>
            <param name="data">序列化之后的数据</param>
            <returns>反序列化之后的对象</returns>
        </member>
        <member name="T:PinFun.Core.Utils.Utils.ProtoBuffer">
            <summary>
            ProtoBuf序列化与反序列化
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.ProtoBuffer.Serialize(System.Object)">
            <summary>
            序列化数据
            </summary>
            <param name="data">待序列化的对象</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.ProtoBuffer.DeSerialize``1(System.Byte[])">
            <summary>
            反序列化
            </summary>
            <typeparam name="T">目标类型</typeparam>
            <param name="data">数据</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Utils.Utils.Zip">
            <summary>
            ZIP文件压缩与解压，注意，解压可能仅支持本工具产生的压缩文件
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.Zip.ZipDir(System.String,System.String,System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            压缩指定的目录，并且输出到指定文件
            </summary>
            <param name="dir">待压缩的目录</param>
            <param name="outputFile">输出文件</param>
            <param name="fileFilter">文件筛选器, 返回true则添加添加到压缩文件，否则跳过</param>
            <param name="deleteOutputIfExist">如果目标文件存在，是否删除，如果不删除，那么会抛出异常</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Utils.Utils.Zip.UnZip(System.String,System.String)">
            <summary>
            解压文件
            </summary>
            <param name="zipFile">待解压的文件</param>
            <param name="outputDir">输出目录</param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Utils.WinConsoleLogAppender">
            <summary>
            扩展的Windows控制台日志
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.WinConsoleLogAppender.Close">
            <summary>
            关闭日志
            </summary>
        </member>
        <member name="M:PinFun.Core.Utils.WinConsoleLogAppender.DoAppend(log4net.Core.LoggingEvent)">
            <summary>
            添加日志
            </summary>
            <param name="loggingEvent"></param>
        </member>
        <member name="P:PinFun.Core.Utils.WinConsoleLogAppender.Name">
            <summary>
            日志名称
            </summary>
        </member>
        <member name="T:PinFun.Core.Worker.IAutoStartWorker">
            <summary>
            该接口仅用作寻找所有AutoStartWorker实现
            </summary>
        </member>
        <member name="T:PinFun.Core.Worker.AutoStartWorker`1">
            <summary>
            自动启动的Worker, 这些Work只能具有一个实例，且会在所有已经注册的服务启动前启动
            <para>这些自启动Worker不会被用户关闭</para>
            </summary>
        </member>
        <member name="P:PinFun.Core.Worker.AutoStartWorker`1.Instance">
            <summary>
            获取当前类的唯一实例
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.AutoStartWorker`1.#ctor">
            <summary>
            所有仅需要单实例的类，均可继承至该类
            </summary>
        </member>
        <member name="T:PinFun.Core.Worker.AutoStartWorkerManager">
            <summary>
            所有自动启动Worker的管理类
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.AutoStartWorkerManager.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.AutoStartWorkerManager.InvInit">
            <summary>
            反初始化
            </summary>
        </member>
        <member name="T:PinFun.Core.Worker.Worker">
            <summary>
            可采用单线程访问内部数据的对象, 如果采用了<see cref="T:PinFun.Core.DependenceInversion.DepInvImplementAttribute"/>标记，且设置为单实例，那么会自动被调用Start方法
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.#ctor">
            <summary>
            新建一个Worker
            </summary>
        </member>
        <member name="P:PinFun.Core.Worker.Worker.IsInWorkerThread">
            <summary>
            获取当前运行线程是否在工作线程内
            </summary>
        </member>
        <member name="P:PinFun.Core.Worker.Worker.ScheduleInterval">
            <summary>
            定时计划，默认值为5，单位秒，任务执行间隔为至上次执行完毕为准
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.Kill">
            <summary>
            释放资源，关闭该Worker
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.Start">
            <summary>
            启动计划任务，调用之后会执行一次OnScheduledTask方法，如果返回false，第一次调用是在当前线程完成的，并非工作线程
            本次执行OnScheduledTask的异常将直接抛出
            </summary>
        </member>
        <member name="P:PinFun.Core.Worker.Worker.IsStarted">
            <summary>
            是否已经启动，即 <see cref="M:PinFun.Core.Worker.Worker.Start"/> 方法已经执行完毕
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.AfterStart">
            <summary>
            在启动方法调用完毕之后执行，该方法将在内部线程上运行
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.Dispose">
            <summary>
            释放资源，并且关闭Worker
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.TryStartWork">
            <summary>
            尝试开始工作
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.TriggerScheduledTask">
            <summary>
            尝试触发当前的计划任务
            </summary>
            <returns></returns>
        </member>
        <member name="P:PinFun.Core.Worker.Worker.NeedRunAgain">
            <summary>
            是否可以继续运行计划任务
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.OnScheduledTask">
            <summary>
            定期执行的计划任务，如果返回false(基类默认值是false)，那么任务将终止，否则等待<see cref="P:PinFun.Core.Worker.Worker.ScheduleInterval"/>时长之后会再次运行
            <para>注意：在<see cref="M:PinFun.Core.Worker.Worker.Start"/>方法被调用之后，此方法会自动的被调用一次，然后依据其返回值确定后续是否继续调用</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.AddTask(System.MulticastDelegate,System.Object[])">
            <summary>
            向当前Worker添加任务
            </summary>
            <param name="action">任务内容</param>
            <param name="arguments">任务参数</param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.AddTask``1(System.MulticastDelegate,System.Object[])">
            <summary>
            向当前Worker添加具有返回值的任务
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Worker.Worker.AddTaskSync``1(System.MulticastDelegate,System.Object[])">
            <summary>
            [同步]在当前Worker添加具有返回值的任务，并且等待返回值，最长时间5秒，超过5秒将得到异常
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="T:PinFun.Core.Worker.WorkerManager">
            <summary>
            Worker管理程序
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.WorkerManager.#ctor">
            <summary>
            定时任务管理器
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.WorkerManager.Add(PinFun.Core.Worker.Worker)">
            <summary>
            向管理器中增加定时任务
            </summary>
            <param name="worker">定时任务对象</param>
        </member>
        <member name="M:PinFun.Core.Worker.WorkerManager.Remove(PinFun.Core.Worker.Worker)">
            <summary>
            向管理器中移除定时任务
            </summary>
            <param name="worker">定时任务对象</param>
        </member>
        <member name="M:PinFun.Core.Worker.WorkerManager.Dispose">
            <summary>
            释放资源，不在进行循环任务的继续调度
            </summary>
        </member>
        <member name="T:PinFun.Core.Worker.WorkTaskDesc">
            <summary>
            任务描述基类
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.WorkTaskDesc.#ctor(System.MulticastDelegate,log4net.ILog,System.Object[])">
            <summary>
            新建任务描述
            </summary>
            <param name="delegate"></param>
            <param name="log"></param>
            <param name="arguments"></param>
        </member>
        <member name="M:PinFun.Core.Worker.WorkTaskDesc.Invoke">
            <summary>
            反射调用具体方法
            </summary>
            <returns></returns>
        </member>
        <member name="M:PinFun.Core.Worker.WorkTaskDesc.RunTask">
            <summary>
            执行任务
            </summary>
        </member>
        <member name="T:PinFun.Core.Worker.ActionWorkTaskDesc">
            <summary>
            无返回值任务
            </summary>
        </member>
        <member name="P:PinFun.Core.Worker.ActionWorkTaskDesc.Task">
            <summary>
            当前任务的任务对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.ActionWorkTaskDesc.RunTask">
            <summary>
            执行任务
            </summary>
        </member>
        <member name="T:PinFun.Core.Worker.FuncWorkTaskDesc`1">
            <summary>
            带返回值的任务描述
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:PinFun.Core.Worker.FuncWorkTaskDesc`1.Task">
            <summary>
            任务对象
            </summary>
        </member>
        <member name="M:PinFun.Core.Worker.FuncWorkTaskDesc`1.RunTask">
            <summary>
            执行任务
            </summary>
        </member>
    </members>
</doc>
